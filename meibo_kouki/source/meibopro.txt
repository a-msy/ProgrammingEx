     1	/* 
     2	 * File:   meibo.c
     3	 * Author: 09430509
     4	 *
     5	 * Created on 2019/04/10
     6	 * update on 2019/07/26
     7	 */
     8	
     9	#include <stdio.h>
    10	#include <stdlib.h>
    11	#include <string.h>
    12	
    13	#define LIMIT 1024
    14	#define maxsplit 5//最大分割数
    15	#define luck -1
    16	#define over -2
    17	#define endp NULL//strtol 用ポインタ
    18	#define base1 10//10進数
    19	
    20	typedef enum{
    21	    null,LUCK,OVER,NOTDEFINED,
    22	    NORECORD,OVERNUMBERRECORD,
    23	    FORMATINPUT,FORMATID,FORMATDATE,
    24	    NUMITEM,ERRORNUM,NOFILEOPEN,
    25	    OVERNITEMS,PARAMERROR,
    26	} ERROR;
    27	
    28	typedef enum{
    29	    Q,C,P,E,R,W,BR,BW,F,FB,S,QS,D,SIZE,LIST
    30	}HELP;
    31	
    32	struct date {
    33	    int y;//year
    34	    int m;//month
    35	    int d;//day
    36	};
    37	
    38	struct profile{
    39	    int id;//id
    40	    char name[70];//schoolname
    41	    struct date found;
    42	    char add[70];//address
    43	    char *others;//備考
    44	};
    45	
    46	/*subst*/
    47	int subst(char *str,char c1,char c2);
    48	
    49	/*split*/
    50	int split(char *str,char *ret[],char sep,int max);
    51	void error_split(int check);
    52	
    53	/*get_line*/
    54	int get_line(char *input);
    55	int get_line_fp(FILE *fp,char *input);
    56	
    57	/*parse_line*/
    58	void parse_line(char *line);
    59	
    60	void printdata(struct profile *pro, int i);
    61	/*cmd*/
    62	void exec_command(char *cmd, char *param);
    63	void cmd_quit();
    64	void cmd_check();
    65	void cmd_print(struct profile *pro,int param);
    66	void cmd_pex(int param);
    67	void cmd_read(char *filename);
    68	void cmd_write(char *filename);
    69	void cmd_binread(char *filename);
    70	void cmd_binwrite(char *filename);
    71	void cmd_find(char *keyword);
    72	void cmd_findb(char *keyword);
    73	void swap_struct(struct profile *i, struct profile *j);
    74	int compare_profile(struct profile *p1, struct profile *p2, int column);
    75	int compare_date(struct date *d1, struct date *d2);
    76	void cmd_sort(int youso);
    77	void cmd_qsort(int youso);
    78	int partition (int left, int right,int youso);
    79	void quick_sort(int left, int right,int youso);
    80	void cmd_delete(int param);
    81	void cmd_help();
    82	void cmd_size();
    83	int find_kai(char *s, char * cp);
    84	
    85	
    86	
    87	/*profile*/
    88	struct profile *new_profile(struct profile *pro,char *str);
    89	char *date_to_string(char buf[],struct date *date);
    90	
    91	/*GLOBAL*/
    92	struct profile profile_data_store[10000];
    93	int profile_data_nitems = 0;
    94	int quick_count = 0;
    95	
    96	/*MAIN*/
    97	int main(void){
    98	
    99	    char line[LIMIT + 1];
   100	    while (get_line(line)) {
   101	        parse_line(line);
   102	    }
   103	    return 0;
   104	
   105	}
   106	
   107	int subst(char *str,char c1,char c2){
   108	    int count = 0;
   109	    while(*str != '\0'){
   110	        if(*str == c1){
   111	            *str = c2;
   112	            count++;
   113	        }
   114	        str++;
   115	    }
   116	    return count;
   117	}
   118	
   119	int split (char *str,char *ret[],char sep,int max){
   120	    int count = 0;//分割数
   121	
   122	    while (1) {
   123	        if(*str == '\0') {
   124	            break;//からもじなら抜ける
   125	        }
   126	       
   127	        if(count>max)break;
   128	        ret[count++] = str;//strをいじればretも変わるように分割後の文字列にはポインタを入れる
   129	
   130	        while( (*str != '\0') && (*str != sep) ){//区切り文字が見つかるまでポインタすすめる 
   131	            str++;
   132	        }
   133	        
   134	        if(*str == '\0') {
   135	            break;//区切り文字がなかったら抜ける＝文字列はそのまま
   136	        }                                                                                                   
   137	
   138	        *str = '\0';//必ず区切り文字のはずだからくぎる
   139		    str++;//インクリメントさせる  
   140	    }
   141	
   142	    if(count<max)count = luck;
   143	    else if(count>max)count = over;
   144	    return count;
   145	}
   146	
   147	int get_line(char *input){
   148	    return get_line_fp(stdin,input);
   149	}
   150	
   151	int get_line_fp(FILE *fp,char*input){
   152	    fprintf(stderr,"\n>>>>>");
   153	    
   154	    if (fgets(input, LIMIT + 1, fp) == NULL){
   155	        fprintf(stderr,"ERROR %d:NULL--getline()\n",null);
   156	        return 0; /* 失敗EOF */
   157	    }
   158	    subst(input, '\n', '\0');
   159	    
   160	    return 1; /*成功*/
   161	}
   162	
   163	void error_split(int check){
   164	    switch(check){
   165	        case luck:
   166	            fprintf(stderr,"ERROR %d:luck--split()\n",LUCK);
   167	            break;
   168	        
   169	        case over:
   170	            fprintf(stderr,"ERROR %d:over--split()\n",OVER);
   171	            break;
   172	        
   173	        default:
   174	            break;
   175	    }
   176	    return;
   177	}
   178	
   179	void parse_line(char *line){
   180	    char *ret[2];
   181	    int com=0;
   182	    
   183	    if(line[0]=='%'){
   184	        com=split(line,ret,' ',2);
   185	        exec_command(ret[0], ret[1]);
   186	    }
   187	    else{
   188	        new_profile(&profile_data_store[profile_data_nitems],line);
   189	    }
   190	}
   191	
   192	void exec_command(char *cmd, char *param){
   193	    if(strcmp(cmd,"%Q")==0||strcmp(cmd,"%q")==0){
   194	        cmd_quit();
   195	    }
   196	    else if(strcmp(cmd,"%C")==0||strcmp(cmd,"%c")==0){
   197	        cmd_check();
   198	    }
   199	    else if(strcmp(cmd,"%E")==0||strcmp(cmd,"%e")==0){
   200	        cmd_pex(strtol(param,endp,base1));
   201	    }
   202	    else if(strcmp(cmd,"%P")==0||strcmp(cmd,"%p")==0){
   203	        cmd_print(&profile_data_store[0],strtol(param,endp,base1));
   204	    }
   205	    else if(strcmp(cmd,"%R")==0||strcmp(cmd,"%r")==0){
   206	        cmd_read(param);
   207	    }
   208	    else if(strcmp(cmd,"%W")==0||strcmp(cmd,"%w")==0){
   209	        cmd_write(param);
   210	    }
   211	    else if(strcmp(cmd,"%F")==0||strcmp(cmd,"%f")==0){
   212	        cmd_find(param);
   213	    }
   214	    else if(strcmp(cmd,"%FB")==0||strcmp(cmd,"%fb")==0){
   215	        cmd_findb(param);
   216	    }
   217	    else if(strcmp(cmd,"%D")==0||strcmp(cmd,"%d")==0){
   218	        cmd_delete(strtol(param,endp,base1));
   219	    }
   220	    else if(strcmp(cmd,"%S")==0||strcmp(cmd,"%s")==0){
   221	        cmd_sort(strtol(param,endp,base1));
   222	    }
   223	    else if(strcmp(cmd,"%QS")==0||strcmp(cmd,"%qs")==0){
   224	        cmd_qsort(strtol(param,endp,base1));
   225	    }
   226	    else if(strcmp(cmd,"%H")==0||strcmp(cmd,"%h")==0){
   227	        cmd_help();
   228	    }
   229	    else if(strcmp(cmd,"%BW")==0||strcmp(cmd,"%bw")==0){
   230	        cmd_binwrite(param);
   231	    }
   232	    else if(strcmp(cmd,"%BR")==0||strcmp(cmd,"br")==0){
   233	        cmd_binread(param);
   234	    }
   235	    else if(strcmp(cmd,"%SIZE")==0||strcmp(cmd,"size")==0){
   236	        cmd_size();
   237	    }
   238	    else {
   239	        fprintf(stderr, "ERROR %d:%s command is not defined.--exec_command()\n",NOTDEFINED,cmd);
   240	        fprintf(stderr,"command list : %%H\n");
   241	    }
   242	 }
   243	
   244	void cmd_help(){
   245	    int i;
   246	    char help_list[LIST][40]=
   247	    {
   248	        "Q : quit system","C : check data num","P [value] : print data",
   249	        "E : print specified data","R [filename] : read csv data","W [filename] : write csv data",
   250	        "BR : read binary data","BW : write binary data",
   251	        "F [word] : Exact match search","FB [word] : Partial match search",
   252	        "S [value] : sort (bubble)","QS [value] : quick sort",
   253	        "D [value] : delete data","SIZE : size check",
   254	    };
   255	
   256	    for(i=0;i<LIST;i++){
   257	        fprintf(stderr,"%s\n",help_list[i]);
   258	    }
   259	
   260	    return ;
   261	}
   262	
   263	void cmd_quit(){
   264	    fprintf(stderr,"Are you sure you want to quit?(y or n)>>>");
   265	    if(fgetc(stdin)=='y'){
   266	        fprintf(stderr, "END SYSTEM.\n");
   267	        exit(0);
   268	    }
   269	    else{
   270	        return; 
   271	    }
   272	}
   273	
   274	void cmd_check(){
   275	    fprintf(stdout,"%d profile(s)\n",profile_data_nitems);
   276	    return;
   277	}
   278	
   279	void cmd_print(struct profile *pro,int param){
   280	    if(profile_data_nitems == 0){
   281	        fprintf(stderr,"ERROR %d:No record. No print.--cmd_print()\n",NORECORD);
   282	        return ;
   283	    }
   284	    int i;
   285	    
   286	    if(param == 0){//０のとき
   287	    fprintf(stderr, "******print record data******\n");
   288	        for(i=0;i<profile_data_nitems;i++){
   289	            printdata(pro+i,i);
   290	        }
   291	    }
   292	    
   293	    else if(param > 0){//正のとき
   294	        
   295	        if( param > profile_data_nitems ){
   296	            fprintf(stderr,"ERROR %d:over number of record.--cmd_print()\n",OVERNUMBERRECORD);
   297	            fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
   298	            return;
   299	        }
   300	        fprintf(stderr, "******print record data******\n");
   301	        for(i = 0;i<param;i++){
   302	            printdata(pro+i,i);
   303	        }
   304	    }
   305	    
   306	    else if(param < 0){//負の時
   307	        
   308	        param *= -1;
   309	        if( param > profile_data_nitems ){
   310	            fprintf(stderr,"ERROR %d:over number of record.--cmd_print()\n",OVERNUMBERRECORD);
   311	            fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
   312	            return;
   313	        }
   314	        pro += profile_data_nitems-param;
   315	        fprintf(stderr, "******print record data******\n");
   316	        for(i=0 ;i<param;i++){
   317	            printdata(pro+i,profile_data_nitems-param+i);
   318	        }
   319	    }
   320	    return;
   321	}
   322	
   323	void printdata(struct profile *pro, int i){
   324	    fprintf(stderr,"data  : %5d ------------------------------\n",i+1);
   325	    fprintf(stdout,"Id    : %d\n",pro->id);
   326	    fprintf(stdout,"Name  : %s\n",pro->name);
   327	    fprintf(stdout,"Birth : %04d-%02d-%02d\n",pro->found.y,pro->found.m,pro->found.d);
   328	    fprintf(stdout,"Addr  : %s\n",pro->add);
   329	    fprintf(stdout,"Com.  : %s\n\n",pro->others);
   330	    fprintf(stderr,"--------------------------------------------\n");
   331	}
   332	
   333	void cmd_pex(int param){
   334	    if(profile_data_nitems == 0 || param == 0){
   335	        fprintf(stderr,"ERROR %d:No record. No print.--cmd_print()\n",NORECORD);
   336	        return ;
   337	    }
   338	
   339	    if(param<0){
   340	        param*=(-1);
   341	    }
   342	
   343	    if( param > profile_data_nitems){
   344	            fprintf(stderr,"ERROR %d:over number of record.--cmd_print()\n",OVERNUMBERRECORD);
   345	            fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
   346	            return;
   347	    }
   348	    param-=1;
   349	    printdata(&profile_data_store[param],param);
   350	    return;
   351	}
   352	
   353	void cmd_read(char *filename){
   354	    char line[LIMIT+1];
   355	    FILE *fp;
   356	    
   357	    if((fp = fopen(filename,"r"))==NULL){
   358	        fprintf(stderr,"ERROR %d:openfile error!!!---cmd_read()\n",NOFILEOPEN);
   359	        return;
   360	    }
   361	    while(get_line_fp(fp,line)){
   362	        parse_line(line);
   363	    }
   364	    fclose(fp);
   365	    return;
   366	}
   367	
   368	void cmd_write(char *filename){
   369	    FILE *fp;
   370	    int i;
   371	    if((fp = fopen(filename,"w"))==NULL){
   372	        fprintf(stderr,"ERROR %d:openfile error!!!---cmd_write()\n",NOFILEOPEN);
   373	        return;
   374	    }
   375	    for(i=0;i < profile_data_nitems;i++){
   376	        fprintf(fp,"%d,",profile_data_store[i].id);
   377	        fprintf(fp,"%s,",profile_data_store[i].name);
   378	        fprintf(fp,"%04d-%02d-%02d,",profile_data_store[i].found.y,profile_data_store[i].found.m,profile_data_store[i].found.d);
   379	        fprintf(fp,"%s,",profile_data_store[i].add);
   380	        fprintf(fp,"%s",profile_data_store[i].others);
   381	        fprintf(fp,"\n");
   382	    }
   383	    fclose(fp);
   384	    fprintf(stderr,"wrote %s\n",filename);
   385	    return;
   386	}
   387	
   388	void cmd_binread(char *filename){
   389	    return;    
   390	}
   391	
   392	void cmd_binwrite(char *filename){
   393	    FILE *fp;
   394	    int i=0;
   395	    if (fopen(filename, "wb") == NULL)
   396	    {
   397	        fprintf(stderr,"ERROR %d:openfile error!!!---cmd_write()\n",NOFILEOPEN);
   398	        return;
   399	    }
   400	    fwrite(&profile_data_store[0],sizeof(struct profile),1,fp);
   401	    fclose(fp);
   402	    fprintf(stderr,"wrote %s\n",filename);
   403	    return;
   404	}
   405	
   406	char *date_to_string(char buf[],struct date *date){
   407	    sprintf(buf,"%04d-%02d-%02d",date->y,date->m,date->d);
   408	    return buf;
   409	}
   410	
   411	void cmd_find(char *keyword){
   412	    int i,check=0;
   413	    struct profile *p;
   414	    char found_str[11];
   415	    
   416	    for(i=0;i < profile_data_nitems;i++){
   417	        p=&profile_data_store[i];
   418	        date_to_string(found_str,&p->found);
   419	        if( 
   420	                (p->id) == strtol(keyword,endp,base1)||
   421	                strcmp(p->name,keyword)==0||
   422	                strcmp(p->add,keyword)==0||
   423	                strcmp(p->others,keyword)==0||
   424	                strcmp(found_str,keyword)==0
   425	            ){
   426	                printdata(p,i);
   427	                check=1;
   428	        }
   429	    }
   430	    
   431	    if(check==0){
   432	        fprintf(stderr,"No match data.\n");
   433	    }
   434	    
   435	    return;
   436	}
   437	
   438	void cmd_findb(char *keyword){
   439	    int i,check=0;
   440	    struct profile *p;
   441	    char found_str[11];
   442	    
   443	    for(i=0;i < profile_data_nitems;i++){
   444	        p=&profile_data_store[i];
   445	        date_to_string(found_str,&p->found);
   446	        if( 
   447	                (p->id) == strtol(keyword,endp,base1)||
   448	                find_kai(p->name,keyword)==0||
   449	                find_kai(p->add,keyword)==0||
   450	                find_kai(p->others,keyword)==0||
   451	                find_kai(found_str,keyword)==0
   452	            ){
   453	                printdata(p,i);
   454	                check=1;
   455	        }
   456	    }
   457	    if(check==0){
   458	        fprintf(stderr,"No match data.\n");
   459	    }
   460	    return;
   461	}
   462	
   463	int find_kai(char *s, char * cp){
   464		char *s1, *s2;
   465		if( *cp == '\0') return 1; /*cpの文字列長が0ならsを返す*/ 
   466	
   467		while( *s != '\0'){
   468			while(*s != '\0' && *s != *cp) {/*先頭文字が合うまで探す*/
   469				s++;
   470			}
   471			if(*s == '\0') return 1;/*見つからない*/
   472			s1 = s;
   473			s2 = cp;
   474			while ( *s1 == *s2 && *s1 != '\0'){ /*cpの先頭以降の文字列が一致するか*/
   475				s1++;
   476				s2++;
   477			}
   478			if( *s2 == '\0'){/* cp の文字列は、全て一致した*/
   479	    
   480				return 0;
   481			}
   482			s++; /*次の位置から、調べ直す*/
   483		}
   484		return 1;/*見つからない*/
   485	}
   486	
   487	void swap_struct(struct profile *i, struct profile *j){
   488	    struct profile temp;
   489	    
   490	    temp = *j;
   491	    *j = *i;
   492	    *i = temp;
   493	    
   494	    return;
   495	}
   496	
   497	int compare_profile(struct profile *p1, struct profile *p2, int youso){
   498	    if(youso < 0)youso*=-1;
   499	  switch (youso) {
   500	    case 1:
   501	      return (p1->id) - (p2->id);break;
   502	
   503	    case 2:
   504	      return strcmp(p1->name,p2->name);break;
   505	      
   506	    case 3:
   507	      return compare_date(&p1->found,&p2->found);break;
   508	
   509	    case 4:
   510	      return strcmp(p1->add, p2->add);break;
   511	
   512	    case 5:
   513	      return strcmp(p1->others, p2->others);break;
   514	    
   515	    default:
   516	        return 0;break;
   517	    }
   518	}
   519	
   520	int compare_date(struct date *d1, struct date *d2){
   521	  if (d1->y != d2->y) return d1->y - d2->y;
   522	  if (d1->m != d2->m) return d1->m - d2->m;
   523	  return (d1->d) - (d2->d);
   524	}
   525	
   526	void cmd_sort(int youso){
   527	    int i,j;
   528	    int check=0;
   529	
   530	    if(youso>5||youso<1){
   531	        fprintf(stderr,"ERROR %d:sort param is 1 to 5.---cmd_sort()\n",PARAMERROR);
   532	        return;
   533	    }
   534	    
   535	    if(profile_data_nitems<=0){
   536	        return;
   537	    }
   538	
   539	    for(i=0;i<profile_data_nitems;i++){
   540	        for(j=0;j<profile_data_nitems-1;j++){
   541	            if(compare_profile(&profile_data_store[j],&profile_data_store[j+1],youso) > 0){
   542	                swap_struct(&profile_data_store[j],&profile_data_store[j+1]);
   543	                check++;
   544	            }
   545	        }
   546	    }
   547	    fprintf(stderr,"%d swap.\n",check);
   548	    return;
   549	}
   550	
   551	void cmd_qsort(int youso){
   552	        if(youso>5||youso<1){
   553	        fprintf(stderr,"ERROR %d:sort param is 1 to 5.---cmd_sort()\n",PARAMERROR);
   554	        return;
   555	    }
   556	    
   557	    if(profile_data_nitems<=0){
   558	        return;
   559	    }
   560	    quick_sort(0,profile_data_nitems-1,youso);
   561	    fprintf(stderr,"quicksort end.===count:%d\n",quick_count);
   562	    quick_count=0;
   563	    return;
   564	    
   565	}
   566	
   567	void quick_sort(int left, int right,int youso){
   568	    int i,j,pivot;
   569	    
   570	    i=left; 
   571	    j=right;
   572	    pivot=right;
   573	    
   574	    while(1){
   575	        while (compare_profile(&profile_data_store[i],&profile_data_store[pivot],youso) < 0){
   576	            i++;
   577	        }
   578	        while (compare_profile(&profile_data_store[pivot],&profile_data_store[j],youso) < 0){
   579	            j++;
   580	        }
   581	        if(i>=j)break;
   582	        swap_struct(&profile_data_store[i],&profile_data_store[j]);
   583	        quick_count++;
   584	        i++;
   585	        j--;
   586	    }
   587	    
   588	    if (left < i - 1){               /* 基準値の左に 2 以上要素があれば */
   589	        quick_sort(left, i-1,youso);/* 左の配列をソートする */
   590	    }
   591	    if (j + 1 <  right){              /* 基準値の右に 2 以上要素があれば */
   592	        quick_sort(j+1, right,youso);/* 右の配列をソートする */
   593	    }
   594	    return;
   595	}
   596	
   597	void cmd_delete(int param){
   598	    int i;
   599	    if( param > profile_data_nitems||param <=0){
   600	            fprintf(stderr,"ERROR %d:error param.--cmd_delete()\n",OVERNUMBERRECORD);
   601	            fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
   602	            return;
   603	    }
   604	    for(i=param-1;i<profile_data_nitems-1;i++){
   605	        profile_data_store[i]=profile_data_store[i+1];
   606	    }
   607	    profile_data_nitems-=1;
   608	    return;
   609	}
   610	
   611	struct profile *new_profile(struct profile *pro,char *str){
   612	    char *ret1[maxsplit],*ret2[maxsplit-2];
   613	    int count=0;
   614	    if(profile_data_nitems>=10000){
   615	        fprintf(stderr,"ERROR %d:Can't add record--new_profile()\n",OVERNITEMS);
   616	        return NULL;
   617	    }
   618	    count=split(str,ret1,',',maxsplit);
   619	    if(count!=maxsplit){
   620	        error_split(count);
   621	        fprintf(stderr,"ERROR %d:wrong format of input(ex.001,name,1999-01-01,address,other)--new_profile()\n",FORMATINPUT);
   622	        return NULL;
   623	    }//文字列用
   624	
   625	    pro->id = strtol(ret1[0],endp,base1);
   626	    if( pro->id == 0){
   627	        fprintf(stderr,"ERROR %d:ID is NUMBER.--new_profile()\n",FORMATID);
   628	        return NULL;
   629	    }
   630	
   631	    strncpy(pro->name, ret1[1],70);//名前のコピー
   632	    strncpy(pro->add, ret1[3],70);//住所
   633	    pro->others = (char *)malloc(sizeof(char)*(strlen(ret1[4])+1));
   634	    strcpy(pro->others, ret1[4]);//備考,MAX 1024bytes
   635	
   636	    if(split(ret1[2],ret2,'-',maxsplit-2)!=maxsplit-2){
   637	        fprintf(stderr,"ERROR %d:wrong format of date.(ex.1999-01-01)--new_profile()\n",FORMATDATE);
   638	        return NULL;
   639	    }//設立日
   640	    pro->found.y = strtol(ret2[0],endp,base1);
   641	    pro->found.m = strtol(ret2[1],endp,base1);
   642	    pro->found.d = strtol(ret2[2],endp,base1);
   643	    
   644	    fprintf(stderr,"Add profile.\n");
   645	    profile_data_nitems++;
   646	    return pro;
   647	}
   648	
   649	void cmd_size(){
   650	    fprintf(stderr,"struct profile = %d\n",sizeof(struct profile));
   651	    fprintf(stderr,"id = %d\n",sizeof(profile_data_store[0].id));
   652	    fprintf(stderr,"name = %d\n",sizeof(profile_data_store[0].name));
   653	    fprintf(stderr,"add = %d\n",sizeof(profile_data_store[0].add));
   654	    fprintf(stderr,"found = %d\n",sizeof(profile_data_store[0].found));
   655	    fprintf(stderr,"found.y = %d\n",sizeof(profile_data_store[0].found.y));
   656	    fprintf(stderr,"found.m = %d\n",sizeof(profile_data_store[0].found.m));
   657	    fprintf(stderr,"found.d = %d\n",sizeof(profile_data_store[0].found.d));
   658	    fprintf(stderr,"Com. = %d\n",sizeof(profile_data_store[0].others));
   659	    return;
   660	    //araiment seiyaku
   661	}