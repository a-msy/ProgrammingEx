\documentclass[a4j,11pt]{jarticle}
% ファイル先頭から\begin{document}までの内容（プレアンブル）については，
% 教員からの指示がない限り， { } の中を書き換えるだけでよい．


% ToDo: 提出要領に従って，適切な余白を設定する
\usepackage[top=25truemm,  bottom=30truemm,
            left=25truemm, right=25truemm]{geometry}


% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{プログラミング演習2 \\
       期末レポート}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 今田将也 (IMADA, Masaya) \\
        学生番号: 09430509}

% ToDo: 教員の指示に従って適切に書き換える
\date{出題日: 2019年06月19日 \\
      提出日: 2019年07月27日 \\
      締切日: 2019年07月30日 \\}  % 注：最後の\\は不要に見えるが必要．

% ToDo: 図を入れる場合，以下の1行を有効にする
\usepackage{graphicx}
\usepackage{listings,jlisting}
\lstset{%
  language={C},
  basicstyle={\ttfamily\footnotesize},%
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},%
  numbers=left,%
  xrightmargin=0zw,%
  xleftmargin=3zw,%
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1zw,%
  lineskip=-0.5ex,%
  showstringspaces=false
}

\begin{document}
\maketitle

% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{概要}\label{sec:gaiyou}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

プログラミング演習2においては，プログラミング演習1でC言語の実践的なプログラミングの演習を行った際に不足していた機能を追加した．
ファイルからのcsv形式のデータの読み込み，並びに書き出し．指定語句でデータを検索する機能と，メモリ中のデータを並び替える機能である．
また，完成したプログラムの結果を通して，さらなる不足機能の考察，既存コマンドの改良案と実装方法についての考察を行った．


なお，与えられたプログラムの基本仕様と要件，および，本レポートにおける実装の概要を以下に述べる．プログラムの使用方法についても記載した．

\begin{enumerate}
\setlength{\parskip}{0mm}\setlength{\itemsep}{0mm}%この1行で箇条書きの行間を調整している
\item 仕様
    \begin{enumerate}
    \item 標準入力からID，学校名，設立日，住所，備考からなるコンマ区切り形式 (CSV 形式) の名簿データを受け付けて，それらをメモリ中に登録する機能を持つ．CSV形式の例を以下に示す．

% 波括弧の内部 {...} だけ文字サイズ等を設定する書き方の例
% 以下の例はフォントサイズ：10pt 行送り：11pt
    {\fontsize{8pt}{10pt} \selectfont
        \begin{verbatim}
5100046,The Bridge,1845-11-2,14 Seafield Road Longman Inverness,SEN Unit 2.0 Open
5100224,Canisbay Primary School,1928-7-5,Canisbay Wick,01955 611337 Primary 56 3.5 Open
        :
        \end{verbatim}
    }

    \item ただし\verb|%|で始まるコマンドを受け付けて，登録してあるデータを表示したり整列したりするなどの機能を持つ．実装するコマンドを表\ref{tbl:commands}に示す．
    \end{enumerate}
\item 要件
    \begin{enumerate}
    \item 名簿データは配列などを用いて少なくとも$10000$件のデータを登録できるようにする．
          今回のプログラムでは，構造体\verb|struct profile|の配列\verb|profile_data_store[10000]|を宣言して，
          $10000$件のデータを格納できるようにする．
    \item 名簿データは構造体\verb|struct profile|および構造体\verb|struct date|を利用して，
          構造を持ったデータとしてプログラム中に定義して利用する．
          実装すべきデータ構造は表\ref{tbl:structure_profile}である．
          表中の$n$~bytesとは，$n$バイトの\verb|char|型配列を意味する．
    \end{enumerate}
\end{enumerate}

\begin{table}[t] % 表の位置は原則として t または b である．hやHは使わない．
    \centering % この1行はbegin～endの中を中央寄せにする，というコマンド
    \caption{実装するコマンド}
    \label{tbl:commands}
\begin{tabular}{|l|l|l|}
\hline
コマンド & 解説 & パラメータ範囲 \\ \hline
\verb|%C| & メモリ中のデータ件数を表示する & パラメータなし \\ \hline
\verb|%P| & メモリ中データを，$n$に応じて表示させる & \begin{tabular}[c]{@{}l@{}}n:-10000$\sim$10000\\ ($0$:全件表示\\ $n$\textgreater{}$0$:前から指定件数正順表示\\ $n$\textless{}$0$:後ろから指定件数正順表示)\end{tabular} \\ \hline
\verb|%Q| & システムを終了する & パラメータなし \\ \hline
\verb|%R| filename& filenameファイルからcsvデータを読みこむ & filename\\ \hline
\verb|%W| filename& メモリ中のデータをfilenameファイルに書き出す & filename\\ \hline
\verb|%F| word& システムを終了する & word\\ \hline
\verb|%S n| & システムを終了する & n:1から5までの正整数 \\ \hline

\end{tabular}
\end{table}
	\begin{table}[t]
	\centering % この1行はbegin～endの中を中央寄せにする，というコマンド
    \caption{名簿データ}
    \label{tbl:structure_profile}
\begin{tabular}{|l|l|l|l|l|}
\hline
ID      & 学校名      & 設立日         & 住所     & 備考  \\ \hline
32bit整数 & 70 bytes & \verb|struct date| & 70bytes & 任意長 \\ \hline
\end{tabular}
	\end{table}

また，本レポートでは以下の考察課題について考察をおこなった．

\begin{enumerate}
\setlength{\parskip}{2pt}\setlength{\itemsep}{2pt}%この1行で箇条書きの行間を調整している
    \item 不足機能に関する考察
    \item エラー処理に関する考察
    \item 新規コマンドの実装
    \item 既存コマンドの改良
\end{enumerate}
また，発展的な考察として，以下の内容についても考察を行った．
\begin{enumerate}
    \setlength{\parskip}{2pt}\setlength{\itemsep}{2pt}%この1行で箇条書きの行間を調整している
    \item 構造体のサイズ
    \item 本課題の要件に対する考察
    \item コマンドの拡張
    \item テキスト形式とバイナリ形式
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの作成方針}\label{sec:housin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

プログラムをおおよそ以下の部分から構成することにした．
それぞれについて作成方針を立てる．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item 必要なデータ構造の宣言部（\ref{sec:declare}節）
    \item 標準入力から得た CSV データの解析部（\ref{sec:parse}節）
    \item 構文解析したデータの内部形式への変換部（\ref{sec:exchange}節）
    \item 各種コマンド実現部（\ref{sec:command}節）
\end{enumerate}


%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{宣言部} 
\label{sec:declare}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

``宣言部''は必要な構造体を宣言する部分である．
このレポートでは概要で示した表\ref{tbl:structure_profile}に基づいて，
以下のように宣言する．

{\fontsize{10pt}{11pt} \selectfont
\begin{verbatim}
    struct date {
      int y;
      int m;
      int d;
    };

    struct profile {
      int id;
      char name[70];
      struct date found;
      char add[70];
      char *others;
    };

     struct profile profile_data_store[10000];

     int profile_data_nitems = 0;

\end{verbatim}
}

ここでは，名簿管理に必要なデータを定義している．\verb|struct date|においては，設立日の設定に必要な変数\verb|y|，\verb|m|，\verb|d|を定義した．順に，設立年，設立月，設立日を表している．\verb|struct profile|では，一つ当たりデータの構造を作るために利用している．\verb|int id|はID，\verb|char name|は学校名，\verb|struct| \verb|date found|は設立日，\verb|char add|は住所，\verb|char others|は備考を設定している．これにより仕様に必要なデータを格納することが可能になっている．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{解析部} \label{sec:parse}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

``解析部''は入力された文字列を判別し処理をおこなう箇所である．
しかし，このままでは，仕様を実現するための方法が曖昧であるうえフローチャートも複雑になる懸念があるうえ，今回の仕様の実現には手間が多くかかりそうである．
そこで，段階的詳細化の考え方に基づいてさらなる詳細化をおこなって，プロトタイプを作りながらボトムアップによる実装をすることにした．
まず，下記の(a)から(e)のように分割することにする．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
\renewcommand{\labelenumi}{(\alph{enumi})} % この1行はリスト見出しを(a), (b)に変えるためのコマンド
    \item 標準入力から読むべき行が残っている間，文字の配列\verb|char line[]|に1行分を読み込む．
    \item \verb|line|の1文字目が，\verb|'%'|ならば，2文字目をコマンド名，3文字目以降をその引数として，決定されたコマンドを実行する．
    \item さもなくば\verb|line|を新規データとみなし\verb|','|を区切りとして5つの文字列に分割する．
    \item 分割してできた5つの文字列を変換部に渡し構造体に代入する．
    \item 次の行を読み込む
\end{enumerate}
コマンドを入力させるか，新規データを入力させるか選択したのちに，以上の処理をさせるように一段階詳細化させることも考慮したが，名簿管理プログラムということが自明であるため，プログラム起動時にコマンドかそうでないかを判別して処理させることで実装した．ここで扱う文字列は最大数が$1024$に限定されているため入力文字数に注意する必要がある．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{変換部} \label{sec:exchange}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

``変換部''は分割されたCSVデータもしくは新規入力データを項目毎に型変換し，
対応する構造体メンバに代入する部分である．
メンバとして様々な型を用いているため，適切な代入の使い分けが必要となる．

文字列は関数\verb|strcpy|を用いて代入する．
数値の場合，関数\verb|strtol|を用いて文字列を数値に変換してから代入する．
構造体\verb|struct date|であるメンバ\verb|y，m，d|については\verb|split|関数を実行し，文字列を分割してから代入数値としてする．

なお，構造体への代入については，\verb|strcpy|関数を用いることで容易に実装することができる．
例えば，\verb|"2014-10-25"|のような文字列を\verb|split|関数により分割し，
\verb|strcpy|関数によって入力されたデータを\verb|struct profile|内の\verb|struct date|に年と月と日を格納するという処理は，
入力された文字列を\verb|','|により分割する処理と同じ処理である．
従って，区切り文字がCSVの\verb|','|とは異なり，区切り文字が\verb|'-'|になること以外は同様に記述できるはずである．

また，解析部から与えられた文字列はメモリ内に保持されているものではないデータであることにも注意する必要がある．
つまり，変換部で文字列を処理する際には，入力された文字列に対して変換を行い，結果を表示をするだけではなく，
関数\verb|new_profile|を使って受け取ったデータをメモリ内に保持しておく作業を行わなければならないことに気をつける必要がある．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{各種コマンド実現部} \label{sec:command}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

``各種コマンド実現部''は，表\ref{tbl:commands}にある実装コマンドの，実際の処理をおこなう部分である．
このレポートでは，具体的には，登録されているデータ件数を表示する機能と，指定形式でデータ内容を表示する機能，
外部ファイルからデータを読み込む機能，外部ファイルに書き出す機能，メモリ中のデータを並び替える機能，
データを検索する機能，また，システムを終了させるための機能の7つを実装している．

\verb|%Q|はシステムを終了させる．

登録されているデータ件数を表示するためには（\verb|%C|），グローバル変数にて宣言している
\verb|profile| \verb|_data| \verb|_nitems|の値を表示すればよい．グローバル変数で宣言したのにも理由があり，
\verb|main|関数内でこの変数を宣言してしまうと，別関数で利用する際に値の受け渡しが発生し，手間が増えるためグローバル変数として宣言した．

登録されているデータを表示するには（\verb|%P n|）は\verb|printf|関数でメモリ内のデータを各項目毎に表示すればよい．
ただし，与えられた引数が負の場合は，逆順ではなくデータを後ろから正順で表示するため，ポインタの位置に注意する必要がある．
また，データ件数が0件の場合でも上記コマンドは実行されるが，データがないという表示を行わせている．

外部ファイルからのデータの入力(\verb|%R|)はファイル構造体のポインタを作成し，\verb|fopen()|関数を用いた．
データの書き出し(\verb|%W|)も同様に実装したが，オープンモードが異なることに注意しなければならない．
なお，書き出しの際は読み込んだファイルのCSVデータと同様の形式で書き出す仕様である.

データ検索(\verb|%F|)は，引数として入力された語句がそれぞれのデータの要素に完全一致しているかどうかで実装した．
設立日については，年月日を分割して保存したため再度文字列に変換してから文字列比較を行った．しかし後に部分一致による実装も行った．

データ整列(\verb|%S|)は整列の条件式でデータの大小を比較してバブルソートにて実装していたがクイックソートへ変更した．
変更した理由については後ほど述べる．
比較の際，文字列データについては2つの文字列の大小を比較できる\verb|strcmp()|関数を用いた．
設立日は年月日ごとに比較を行わせた．数値データは単純に減算し大小比較をしている．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムおよびその説明}\label{sec:explain}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

プログラムリストは\ref{sec:program}節に添付している．プログラムは全部で661行からなる．
以下では，前節の作成方針における分類に基づいて，プログラムの主な構造について説明する．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{汎用的な関数の宣言（107行目から161行目）}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

まず，汎用的な文字列操作関数として，
\verb|subst()|関数を107から117行目で宣言し，\verb|split()|関数を119から145行目で宣言，
さらに\verb|get_line()|に関係する関数を147から161行目で宣言している．

\verb|subst| は，引数の\verb|str|が指す文字列中の\verb|c1|文字を\verb|c2|に置き換える．
プログラム中では，入力文字列中の末尾に付く改行文字をヌル文字で置き換えるために使用している．

\verb|split| は 引数の\verb|str| が指す文字列を区切文字 \verb|c| で分割し，
分割した各々の文字列を指す複数のポインタからなる配列を返す関数である．
プログラム中では，CSVを\verb|','|で分割し，分割後の各文字列を返すのに使用されている．
また，''2004-05-10'' のような日付を表す文字列を '-' で分割して，\verb|struct date| を生成する際にも使用している．

\verb|get_line()|は，標準入力からの入力を受け付ける処理を当初実装していたが，ファイルポインタからの入力に対応ができていなかった．
そのため，それに対応した\verb|get_line_fp()|関数をファサードした．
\verb|get_line_fp()|関数はファイルポインタからの読み込みを行う関数で，\verb|get_line()|関数ではその引数として
\verb|stdin|を渡して標準入力からも受け取れるようにした．

構造体のデータを一件出力するための関数として\verb|printdata()|を，構造体を入れ替える関数として\verb|swap_struct()|関数を宣言した．
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{変換部（32行目から44行目，611行目から647行目）}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

32から36行目は \verb|struct date| 型の宣言部である．メンバについては，変数\verb|y|は設立年，変数\verb|m|は設立月，
変数\verb|d|は設立日にそれぞれ対応させている．

38から44行目は \verb|struct profile| 型の宣言部である.なお611〜647行目はそれを扱う関数\verb|new_profile|である．
メンバについては，設立日を入れ子構造にしている．
こうすることで，要素を管理しやすくできる．なお，備考に対応する文字列\verb|*others|は任意長を許すようにしているため，
\verb|malloc|関数と\verb|strlen|関数を用いて文字列を動的に格納できるようにした. 
文字列から各データ型への変換を担う関数は，\verb|struct new\_profile| とすることで，変換部であることを明確にした．
具体的な処理内容としては，受け取った文字列\verb|str|を分割し，分割した文字列を\verb|ret1[]|に格納し，
その後要素ごとに対応する構造体メンバにエラー検出のある\verb|strncpy|関数を用いて格納している．設立日については，
\verb|ret2[]|を用意し，各メンバに対応するよう格納させている．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{各種コマンド実現部（244行目から604行目）}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
244行目からの各種コマンド実現に必要な関数群は，\verb|cmd_処理名| という名前に統一することで，関数であることを明確にした．
コマンド\verb|%P|は\verb|cmd_print()|，コマンド\verb|%C|は\verb|cmd_check()|，
コマンド\verb|%Q|は\verb|cmd_quit()|，コマンド\verb|%R|は\verb|cmd_read()|，
コマンド\verb|%W|は\verb|cmd_write()|, コマンド\verb|%F|は\verb|cmd_find()|, 
コマンド\verb|%S|は\verb|cmd_sort()|にそれぞれ対応している．

192から242行目は，\verb|%P,%C,%Q,%R,%W,%F,%S|のコマンドを解釈して適切な関数を呼び出す部分である．

\verb|%P|は，279から321行目に記載した．
\verb|%C|は，274から277行目に記載した．\verb|%Q|は，263から272行目に記載した．
\verb|%R|は，353から366行目に記載した．\verb|%W|は，368から386行目に記載した．
\verb|%F|は，411から436行目に記載した．\verb|%S|は，526から549行目に記載した．

これらの関数の内容は，表\ref{tbl:commands}に記載した．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{解析部}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
97から105行目は\verb|main()|関数で，
179から190行目は，\verb|parse_line()|関数であり，作成方針で説明した解析部の動作におおよそ相当する．
ただし (c) の5つの文字列に分割する部分は，解析部の\verb|main()|関数では実現せず，
処理内容を明確にするために変換部である\verb|new_profile()|関数中で\verb|split|を呼出し，各要素ごとに分割を
行うことにしている．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの使用法}\label{sec:use}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本プログラムは名簿データを管理するためのプログラムである．
CSV形式のコンマ区切りのデータと \% で始まるコマンドを標準入力から受け付け，
処理結果を標準出力に出力する．入力形式の詳細については，第\ref{sec:gaiyou}節を参照されたい．

プログラムは，CentOSで動作を確認しているが，
一般的な UNIX で動作することを意図している．
\verb|gcc|でコンパイルした後，標準入力から入力ファイルおよびデータを与える．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
   % gcc -Wall -o program1 program1.c
   % ./program1 <　test.txt
 \end{verbatim}
}

プログラムの出力結果としてはCSVデータの各項目を読みやすい形式で出力する．
例えば，下記の \verb|test.txt| に対して，

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
  111,The Bridge,1845-11-2,Okayama,SEN Unit 2.0 Open
  222,Bower School,1908-1-19,Kagawa,01955 641225 Primary 25 2.6 Open
  333,Canisbay School,1928-7-5,Tokyo,01955 611337 Primary 56 3.5 Open
  %C
  %P 0
  %Q
 \end{verbatim}
}
\noindent % noindentとはここでは段落を変えない（一字下げをしない）というコマンド．
以下のような出力を得る．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
　　param is 0.
　　******print record data******
　　data  :     1 ------------------------------
　　Id    : 111
　　Name  : The Bridge
　　Birth : 1845-11-02
　　Addr  : Okayama
　　Com.  : SEN Unit 2.0 Open
　　--------------------------------------------
　　data  :     2 ------------------------------
　　Id    : 222
　　Name  : Bower School
　　Birth : 1908-01-19
　　Addr  : Kagawa
　　Com.  : 01955 641225 Primary 25 2.6 Open
　　--------------------------------------------
　　data  :     3 ------------------------------
　　Id    : 333
　　Name  : Canisbay School
　　Birth : 1928-07-05
　　Addr  : Tokyo
　　Com.  : 01955 611337 Primary 56 3.5 Open
　　--------------------------------------------

 \end{verbatim}
}

\noindent
入力中の\verb|%C|はこれまでの入力データの件数を表示することを示し，\verb|%P 0|は入力したデータのうち，全件のデータを表示することを示している．
なお，\verb|%Q|はシステムを終了することを示す．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{作成過程における考察}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

第\ref{sec:housin}節で述べた実装方針に基づいて，第\ref{sec:explain}節ではその実装をおこなった．
しかし，実装にあたっては実装方針の再検討が必要になる場合があった．
本節では，名簿管理プログラムの作成過程において検討した内容，
および，考察した内容について述べる．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{split}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%

関数\verb|split|については方針通りに実装することができたが，容易に実装することはできなかった．
当初はコンマまでの文字列を別の配列に保存することを繰り返して実装しようとしていたが，これではコンマの数で文字列を判断することになるため失敗した．
そこで文字列を破壊的に分割し別途規定数用意した文字配列にアドレスを格納することで実装できた．文字列を丸ごとコピーすることも考えられたが，
その方法は，入力した倍のメモリ量が必要な上に使わなくなったメモリを開放する手間が増えるため用いなかった．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{get\_line}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
標準入力からの入力について当初は，\verb|main|関数の中で\verb|while|文繰り返し入力を行わせて，入力の度に
入力内容が\verb|NULL|でないか調べ関数\verb|subst|を適用する方法をとっていたが，
\verb|while|文を脱する処理も記述しなければならないため手間が増えた．
そこで，今回は入力内容に問題がなければ$1$を，あれば$0$を返す方針で実装を行った．
これで，もし別の関数内で標準入力からの入力を行う際でも使いまわすことができ汎用性を持たせることができる．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{new\_profile}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
関数\verb|new_profile()|の実装では，単に文字列を受け取り，その文字列を操作した後に，
用意している配列\verb|profile_data_store|にコピーする方法も考えられたが，
値を渡すことになり使用するメモリの量が増えると考えた．
そのため，ポインタによるアドレス渡しによって実装を行った．
また，配列を構造体配列として宣言しているので，ここでは構造体を返り値として設定した．
そして，文字列を数値に変換する際にはエラー検出のある\verb|strtol|関数を用いた．
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{exec\_command}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
仕様を満たす実装はできた．標準入力からのデータは文字列であるため，
各種コマンドへの引数を数値に変換する作業を行っている．この際，\verb|atoi|関数だとうまく変換されないことがあったため\verb|strtol|
関数を用いている．
また，定義されていないコマンドが入力された際は該当するコマンドがないという表示を出すようにした．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_print}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
まず，受け取った\verb|param|の値が正か負か$0$を判断させなくてはならない．
その後，正ならば指定件数分前から順に表示させ，$0$ならば全件表示を行わせて，
負ならば\verb|param|の値を一度正に戻し指定件数分ポインタを移動させた後に正のとき同様に表示処理を行わせる手順で実装を行った．
表示させる部分については，\verb|find|関数にて利用するため\verb|printdata|関数を別途作成し，当該関数内で表示させた．
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_check}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
この関数の実装はあらかじめ，登録件数を保存するための変数をグローバル変数にて宣言することで容易に実装することができた．
誤ったデータが入力された際も当初は件数が増えてしまう実装であったため，増やさないように改変を行った．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_quit}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
この関数の実装は，\verb|stdio.h|にある\verb|exit|関数を利用することにより実装を行った．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_read}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
外部ファイルからのデータ入力は，\verb|stdio.h|にある\verb|fopen|関数並びに\verb|fclose|関数を
利用することで実装した．ファイルポインタの内部の仕組みを理解できてはないが，作成中にファイル名が異なると開けずに
システムが強制終了するため回避する処理が必要だった．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_write}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
上記の\verb|cmd_read|同様に実装行った．ただし，データを書き込むためオープンモードを書き込み状態にした．
\verb|fprintf|を用いてファイルポインタとして開いたファイルにコンマ区切りで書き込むため，データ形式には気を付けた．
1つのデータの終わりに改行を置くことを当初忘れていたため望む実装ができず苦戦した．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_find}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
本関数は，各要素が\verb|%F|の引数として与えられたデータを完全に一致しているかどうかで実装をしようとしたが，入力される引数が文字データで
あることを考慮しておらず苦悩した．構造体\verb|profile|の要素の\verb|name,add,others|は文字であるから\verb|strcmp|関数にて比較可能で，
\verb|id|についても\verb|strtol|関数を用いた比較が可能である．しかし，\verb|found|は年月日ごとに別の構造体に数値としてバラバラにあるため，
一度csvデータと同じ\verb|'-'|で繋がった形式に別途関数を介し変換させた後に別のデータ同様に文字列として比較を行った．

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{関数\texttt{cmd\_sort}についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
ソートについては苦労が大きく実装に手間取った．文字列の比較がわからなかったが\verb|strcmp|関数が数値を返すと知り，
それを用いることで比較を行い要素の大小比較の実装ができた．
要素の大小の結果をソートの比較条件に利用した．データ数が多くなるとソート完了までに時間がかかっていたため，
交換の回数をカウントしバブルソートとクイックソートの比較を行った（第\ref{sec:kison}節)結果，クイックソートも実装した．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{結果に関する考察}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

演習課題のプログラムについて仕様と要件をいずれも満たしていることを
プログラムの説明および使用法における実行結果例によって示した．
ここでは，概要で挙げた以下の項目について考察を述べる．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item 不足機能についての考察
    \item エラー処理についての考察
\end{enumerate}

%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{不足機能についての考察}\label{sec:husoku}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
不足機能については，以下の内容が考えられる．
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
   \item 入力後のデータ修正機能
   \item 指定要素のみ表示させる機能
\end{enumerate}
%-------------------------------------------------------------%
\subsubsection{入力後のデータ修正機能}
%-------------------------------------------------------------%
現在の機能では，データの形式さえあっていれば名簿データとして追加されるため，データの内容を間違って入力しても追加される．
これを回避するために，\ref{sec:sakujyo}節にて指定データを削除する機能を実装している．しかし，削除に再度長いデータを
入力する必要があり不便である．

名前を間違えたら名前のみを，住所を再度編集したい場合は住所のみを書き換えるという機能があればより現実的に利用ができる
名簿管理プログラムになるのではないだろうか．
%-------------------------------------------------------------%
\subsubsection{指定要素のみ表示させる機能}
%-------------------------------------------------------------%
これは\verb|cmd_print|を改良すれば実装ができそうである．
\verb|cmd_print|はすべての要素を表示させている．そこに一つ引数を増やすかもしくは別のコマンドを作成し、
表示させたい要素と数値を紐付けする．例えば$1$ならばIDのみを\verb|%P|のように表示させる実装が可能そうだが，
\verb|%P|の引数が表示件数と要素の2つが必要になりそうであるから実装は困難になるかもしれない．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{エラー処理についての考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item CSVデータ処理中のエラー処理
    \item 登録件数超過おけるエラー処理
    \item split関数のエラー処理
    \item get\_line関数のエラー処理
    \item データ表示時のエラー処理
    \item ファイル入出力のエラー処理
　　\item find関数のエラー処理
\end{enumerate}


%--------------------------------------------------------------%
\subsubsection{CSVデータ処理中のエラー処理}
%--------------------------------------------------------------%

CSVデータ中に，不正なデータが含まれていた場合の処理について考察する．

エラーのあった行を指摘せず，終了または無視するという方法も考えられるが，正常終了との区別が付かない上に，
どの状態でエラーが発生しているのか確認をとることができないため実用的でないと考えた．
今回は，エラーのあった行を指摘して，無視する方法で実装を行っている箇所が多々ある．

プログラム中に\verb|ERROR:|で始まる表示をを書いてエラー目印としている．
また，エラーのあった内容を指摘するためには，\verb|enum|という機能を利用してどのエラーなのかユーザが一度見て理解できるように，
標準エラー出力を利用してエラーの内容を表示させている．

しかし，これはデータの型や仕様に指定されたデータ件数時にしかエラー処理を行っていないため他にも実装の余地はあると考える．
例えば設立年月日について見ると，設立年はマイナス値，
一桁や二桁は不自然だろうし設立月についても$12$より大きい数字は現在の暦では利用されていないはずである．
利用する上でのエラーというものを考慮する必要がある．

%--------------------------------------------------------------%
\subsubsection{登録件数超過におけるエラー処理}
%--------------------------------------------------------------%
本プログラムは，データがすでに10000件ある状態で新規入力が行われた場合でも一度\verb|new| \verb|_profile|関数を実行する．
といっても，関数のはじめにデータ件数を確認しており10000件を超えるデータは保存されないようになっている.

その状態だと条件を調べるために\verb|new_profile|関数を介しメモリを確保するなどと無駄な作業が発生しているため，
内部的な処理目的のためのエラー処理を導入してもよいのではと考えた．

実装案としては，\verb|parse_line|を実行時に条件分岐を行う際にprofile\_data\_nitemsの中身を確認し，
10000件を超えるようであれば処理を行わなくすれば良い．以下実装案のプログラムである．
\begin{verbatim}
void parse_line(char *line){
    if(line[0]=='%'){
        exec_command(line[1], &line[3]);
    }
    else if(profile_data_nitems==10000){
    //件数エラーと表示するもしくは，本関数から抜ける．
    }
    else{
        new_profile(&profile_data_store[profile_data_nitems],line);
    }
}
\end{verbatim}
%--------------------------------------------------------------%
\subsubsection{split関数のエラー処理}
%--------------------------------------------------------------%
\verb|split|関数は，あらかじめ分割数が定められるように実装されている．そのため，その分割数を満たしてないもしくは，
分割数を超えている場合は意図したデータが入力されていないということを判断できる材料になる．

だから，それを利用し分割数を満足していない場合と超えている場合はエラー処理を行わせている．そして，本プログラムでは，split関数は最後まで
処理を行わせている．その後の処理を継続するかどうかについては利用先の関数内で判断させて実装をした．

%--------------------------------------------------------------%
\subsubsection{\texttt{get\_line}関数のエラー処理}
%--------------------------------------------------------------%
標準入力からのデータの受付を行う際は，NULLというデータを受け取ることはなかった．しかし，csvデータを読み込むときに本関数を利用したところ，
EOPに反応しシステムが異常終了した．そこで，NULLならエラーとし，returnさせるように実装した．
%--------------------------------------------------------------%
\subsubsection{データ表示時のエラー処理}
%--------------------------------------------------------------%
このエラー処理は\verb|%P|に関連する，メモリ内に保存されているデータを表示する時のエラー処理である．
以下の状態の時を考慮した．\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item データ件数が0件のとき
    \item 引数が登録件数より多いとき
\end{enumerate}
他にも，パラメータが負のとき，引数が$0$のときなどを考慮しようとしたが仕様上，役割を持っているため考慮していない．
仮に，何も役割がないとするならば，負のときは正に，引数が0は不正な値として処理させるだろう．

%--------------------------------------------------------------%
\subsubsection{ファイル入出力のエラー処理}
%--------------------------------------------------------------%
\verb|%R,%W|ともに，ファイル名が入力されない場合，もしくは同名のファイルが既に存在してなおかつアクセス権限が与えられていない場合，
システムが落ちる．これを回避するためにファイルポインタがNULLの場合つまりファイルを開けないときにエラー処理を行わせた．
%--------------------------------------------------------------%
\subsubsection{find関数のエラー処理}
%--------------------------------------------------------------%
このエラー処理は作成したプログラムに実装しているものだが，データが見つからなかった場合の表示を行っている．
引数の\verb|keyword|に一致したデータが見つかった場合$1$を，見つからなかった場合を$0$として
予め判定用の変数を用意して処理を行わす．

具体的には，\verb|check|という変数を用意し，検索処理が完了しデータを画面上に表示したあとに変数に$1$を代入し
見つかったということにしている．見つからなかった場合はエラー出力に見つからなかった旨を表示している．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{新規コマンドの実装}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
新規コマンドについては第\ref{sec:husoku}節を基に以下の実装を行った．
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item 指定データの削除コマンド
    \item どのようなコマンドあるか表示するコマンド
    \item 指定番号のデータのみ表示させるコマンド
\end{enumerate}
%--------------------------------------------------------------%
\subsubsection{指定データの削除コマンド}\label{sec:sakujyo}
%--------------------------------------------------------------%
本関数は，\verb|exec_command|に\verb|%D|として新たに定義して利用できるようにした．
処理内容としては簡単なものであり，削除したいデータをその一つあとのデータですべてのデータを上書き
するものである．しかし，データ件数の値である\verb|profiel_data_nitems|の値は減らないため，
その値を一つ減らすことで対応している．

プログラムは第\ref{sec:program}節の597行目から609行目にある関数\verb|cmd_delete|である．
%--------------------------------------------------------------%
\subsubsection{どのようなコマンドあるか表示するコマンド}\label{sec:help}
%--------------------------------------------------------------%
本関数は，増えてきた本プログラムの機能をわかりやすくユーザに伝えるために作成した．
どのような機能があるかを設定し\verb|fprintf|関数を用いて標準エラー出力に出力させている．
出力データを記載した外部データを用意することも考えたが読み込み分手間だからそれは用いなかった．

実装方法は，28行目から30行目のenumとchar型二次元配列を用いて，列挙させた．これを利用した理由としては今後実装するコマンドが
増えたとしても変更が容易だからである．

プログラムは第\ref{sec:program}節の244行目から261行目にある関数\verb|cmd_help|である．\verb|%H|コマンドにて確認できる．
%--------------------------------------------------------------%
\subsubsection{指定番号のデータのみ表示させるコマンド}\label{sec:printyouso}
%--------------------------------------------------------------%
本関数はソートを行う際のデータの整合性を確認しているときに実装した関数である．例えば3000件あるデータの中で，
2900件目を見たいとき，今の段階では少なくとも100件分のデータも一緒に表示されてしまうため処理的にも確認作業を
行う上でも無駄が多くなってしまう．

実装としては\verb|%P|の機能を用いず新たに関数を作り，引数が0のときまたは登録件数を超えたときはエラー処理を行い，
引数が負ならば正に変えているがこれは，データ番号に負はないからである．

プログラムは第\ref{sec:program}節の333行目から351行目にある関数\verb|cmd_pex|である．
\verb|%E|コマンドにて確認できる．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{既存コマンドの改良}\label{sec:kison}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
既存コマンドの改良は以下の内容で行った．
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item　語句の検索の部分一致
    \item \verb|%S|コマンドの高速化
    \item システム終了時の終了確認
\end{enumerate}
%-------------------------------------------------------------%
\subsubsection{語句の検索の部分一致}
%-------------------------------------------------------------%
現在の\verb|cmd_find|は文字列の完全一致による実装であるため，システムとして利用するには不便である．
完全一致ではなく部分一致を行うことができれば検索機能が柔軟になると考えた.

実装方法としては，検索される文字列と探したい文字列を比較を行う．検索される文字列の中に探したい文字列の先頭文字があるかどうか探す．
そこから各文字列の文字を一つずつ見ていき，
探したい文字列がすべて見終わったら部分文字列が一致していることになるため検索が可能になると考える．
以下考察したプログラムである．部分文字列が一致すると$0$を返し，それ以外は$1$を返す．
\begin{verbatim}
int find_kai(char *s, char * cp)
{
  char *s1, *s2;
   if( *cp == '\0') return s; /*cpの文字列長が0ならsを返す*/ 

    while( *s != '\0'){
        while(*s != '\0' && *s != *cp) {/*先頭文字が合うまで探す*/
          s++;
        }
        if(*s == '\0') return 1;/*見つからない*/
        s1 = s;
        s2 = cp;
        while ( *s1 == *s2 && *s1 != '\0'){ /*cpの先頭以降の文字列が一致するか*/
            s1++;
            s2++;
        }
        if( *s2 == '\0'){/* cp の文字列は、全て一致した*/
         return 0;
        }
        s++; /*次の位置から、調べ直す*/
    }
    return 1;/*見つからない*/
}
\end{verbatim}
利用する際は\verb|%FB|にて利用する．引数は\verb|%F|と同様である．
%-------------------------------------------------------------%
\subsubsection{\texttt{\%Sコマンドの高速化}}
%-------------------------------------------------------------%
当初の\verb|%S|コマンドでのソートはバブルソートを用いて行っていた．sample.csvデータの2886件程度のデータの
ソートならば時間は気にならなかったが，10000件でソートを行うと待たされる時間があり，もっと早くできないかと思った．

そこで，クイックソートによるソートの実装を行った．\verb|%QS|というコマンドを利用することでクイックソートによる
ソートを実行する．\verb|%S|はバブルソートである．

バブルソートとクイックソートによる交換回数の比較を行った．すべて，IDによるソート後の\verb|Name|のソート回数である．
\begin{table}[t]
    \centering % この1行はbegin～endの中を中央寄せにする，というコマンド
    \caption{比較回数}
\begin{tabular}{|l|l|l|}
\hline
            & データ件数 & 交換回数     \\ \hline
bubble sort & 2886  & 193900   \\ \hline
quick sort  & 2886  & 17715    \\ \hline
bubble sort & 10000 & 23290889 \\ \hline
quick sort  & 10000 & 76963    \\ \hline
\end{tabular}
\end{table}

データ件数が2886件のときでもクイックソートのほうが約10倍速いことがわかる．10000件になるとさらに明確でになり，
クイックソートの方が約300倍速い．
そこで，ソートはクイックソートを実装した．なお，バブルソートでもソートできるよう両方の機能を利用できるようにしている．
%-------------------------------------------------------------%
\subsubsection{システム終了時の終了確認}
%-------------------------------------------------------------%
作成中に誤って\verb|%Q|コマンドを実行してしまいデータを保存せずに終了する事故が発生した．それを回避するために，コマンド実行後さらに
終了してよいかの確認をユーザから受け付けるようにできればよいと考える．

実装はシンプルで\verb|getc|関数を用いて，入力された文字が\verb|y|ならば終了させている．
それ以外の文字や文字列ならばreturnさせてmain関数に再度戻る．ただし，文字列の場合も先頭の一文字のみで判断するため\verb|yyyyyy|
でも反応する．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{発展課題}\label{sec:hatten}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{構造体のサイズ}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
作ったprofile構造体のサイズを調べるために新たにコマンドを作り確認した．第\ref{sec:program}節の649行目から661行目である．
以下その結果を示す．
\begin{verbatim}
>>>>>%SIZE
struct profile = 168
id = 4
name = 70
add = 70
found = 12
found.y = 4
found.m = 4
found.d = 4
Com. = 8
\end{verbatim}
各メンバごとのサイズを合計すると，164であるが，\verb|profile|構造体のサイズは168と差がある．
つまり，4バイト分だけ余分にメモリを確保していることになる．このことについて調べてみると，
多くのCPUがメモリにアクセスする際，4バイトごとにアクセスすることが分かった．このため，4バイト境界をまたぐデータを扱う
と，メモリにアクセスする回数が増える．だから，メンバの\verb|name|と\verb|add|が4の倍数でないため，それを次の4の倍数である72に揃えるために，それぞれ2バイトずつの計4バイトが詰められていると推測できた．
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
\subsection{本課題の要件に対する考察}
%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%
本課題の要件に対する考察として以下のことが考えられる．
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
 \item 入力データの厳密性
 \item コマンド引数の区切り文字
 \item ソート条件の引数
\end{enumerate}
%--------------------------------------------------------------%
\subsubsection{入力データの機密性}
%--------------------------------------------------------------%
本課題の要件には，住所と備考の文字数についての制限が記載されているがその他のデータの制限はとくに決まっていない．
そのため，設立年月日の各メンバに例えば，月に8桁の数字などの本来存在しない値が保存されてしまう．

また，文字をデータとして与える際に英語の半角文字限定での制限なのか日本語も含めた制限なのかについての記載もない．
日本語だとエンコード設定によっては文字化けする可能性もあるため入力データについては厳密性が必要になると考える．

%--------------------------------------------------------------%
\subsubsection{コマンド引数の区切り文字}
%--------------------------------------------------------------%
本課題の要件にある各コマンドの区切り文字は空白であるが，これは\verb|%F|で文字列を検索する際に不便である．
登録されるデータの住所や備考には空欄が入っておりその空欄との判別をする手間がかかりシステムが複雑になることが懸念されるからである．
例えば，次のように入力したとする．
\begin{verbatim}
    %F The Bridge
\end{verbatim}

このようにすると空白が2つ含まれた文字列になり，文字列を空白で\verb|split|関数を用いて分割していると，
\verb|%F|と\verb|The|と\verb|Bridge|と3つにわけることができ，本来ないはずの3つ目の引数として解釈される可能性もある．

これを避けるためにも，入力データ内で利用されていない区切り文字やcsvデータの区切り文字であるコンマなどは避けるべきであると考える．
%--------------------------------------------------------------%
\subsubsection{ソート条件の引数}
%--------------------------------------------------------------%
本課題におけるソート関数である\verb|%S|の仕様として，引数に数字でソートする要素が指定されているが，
ユーザがどの数字がどのデータに対応しているか覚えている必要があるためユーザ体験としては悪いものであると感じた．

そのため，引数を数字ではなく文字で指定するべきであると考えた．具体的には，\verb|Name|や\verb|Add|などのように\verb|%P|で
表示した際の要素の名前で入力させる．これもユーザがメンバの名前を覚える必要があるとは思うが，数字がどの要素に対応しているかよりも
感覚的にわかりやすく，要素の名前も\verb|%P|で確認できるため忘れても問題ないと考える．
%--------------------------------------------------------------%
\subsection{コマンドの拡張}
%--------------------------------------------------------------%
1文字入力のコマンドを2文字以上の入力に対応させるため，\verb|exec_command|関数で当初利用していたswitch文は利用をやめた．
理由としてswitch文は文字列の分岐に対応していないからである．そこで，\verb|parse_line|で\verb|%|の次の文字を\verb|exec_command|
関数に送っていた実装も，\verb|split|関数を介して文字列を\verb|exec_command|関数に渡すように変更した．空白以降のコマンドの引数も
問題なく送れる．

\verb|exec_command|関数での判定は，\verb|strcmp|関数を用いて受け取った文字列を判定している．これにより，2文字よりも多い
コマンドでも受け付けることができるようになる．例として，構造体などのサイズを調べるコマンドとして\verb|%SIZE|が利用できる．

なお，拡張後の関数が\ref{sec:program}節の192行目から242行目と179行目から190行目に記載してある．

%--------------------------------------------------------------%
\subsection{テキスト形式とバイナリ形式}
%--------------------------------------------------------------%
最後の発展課題としてバイナリ形式での書き出しの実装を行おうとした．まず，書き出しを実装しようと
ファイルモードをバイナリに対応した\verb|"wb"|モードにし，1個のデータを書き出そうとしたが392行目から404行目
の実装では実現できなかったため断念した．バイナリ形式のデータが得られなかったため読み込みの実装もできなかった．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{感想}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
１学期の内容よりも遥かに高度で，ポインタやデータ構造における正しい理解が求められる内容に感じた．
特に文字列を扱う関数の実装は難しく大変だった．数値の比較と文字列の比較は完全に別物と考える必要があったし，
もともと数値であるものを文字列に戻し比較を行う処理などもあり苦労したが，その分，実装時に利用した関数の特徴や癖なども
理解できたため大きな経験になった．

そして，自分が欲しいと思った機能（例えば，部分一致やクイックソート）はすでにヘッダファイル内で準備されており，自作をしなくとも
使えることを知ったが，ブラックボックスの状態で利用するよりも自分で内部構造を理解した上で使えることが重要だと感じたため，
容易には用いずに，理解した上で利用したい．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{作成したプログラム}\label{sec:program}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

作成したプログラムを以下に添付する．

\begin{lstlisting}
    /* 
    * File:   meibo.c
    * Author: 09430509
    *
    * Created on 2019/04/10
    * update on 2019/07/26
    */
   
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   
   #define LIMIT 1024
   #define maxsplit 5//最大分割数
   #define luck -1
   #define over -2
   #define endp NULL//strtol 用ポインタ
   #define base1 10//10進数
   
   typedef enum{
       null,LUCK,OVER,NOTDEFINED,
       NORECORD,OVERNUMBERRECORD,
       FORMATINPUT,FORMATID,FORMATDATE,
       NUMITEM,ERRORNUM,NOFILEOPEN,
       OVERNITEMS,PARAMERROR,
   } ERROR;
   
   typedef enum{
       Q,C,P,E,R,W,BR,BW,F,FB,S,QS,D,SIZE,LIST
   }HELP;
   
   struct date {
       int y;//year
       int m;//month
       int d;//day
   };
   
   struct profile{
       int id;//id
       char name[70];//schoolname
       struct date found;
       char add[70];//address
       char *others;//備考
   };
   
   /*subst*/
   int subst(char *str,char c1,char c2);
   
   /*split*/
   int split(char *str,char *ret[],char sep,int max);
   void error_split(int check);
   
   /*get_line*/
   int get_line(char *input);
   int get_line_fp(FILE *fp,char *input);
   
   /*parse_line*/
   void parse_line(char *line);
   
   void printdata(struct profile *pro, int i);
   /*cmd*/
   void exec_command(char *cmd, char *param);
   void cmd_quit();
   void cmd_check();
   void cmd_print(struct profile *pro,int param);
   void cmd_pex(int param);
   void cmd_read(char *filename);
   void cmd_write(char *filename);
   void cmd_binread(char *filename);
   void cmd_binwrite(char *filename);
   void cmd_find(char *keyword);
   void cmd_findb(char *keyword);
   void swap_struct(struct profile *i, struct profile *j);
   int compare_profile(struct profile *p1, struct profile *p2, int column);
   int compare_date(struct date *d1, struct date *d2);
   void cmd_sort(int youso);
   void cmd_qsort(int youso);
   int partition (int left, int right,int youso);
   void quick_sort(int left, int right,int youso);
   void cmd_delete(int param);
   void cmd_help();
   void cmd_size();
   int find_kai(char *s, char * cp);
   
   
   
   /*profile*/
   struct profile *new_profile(struct profile *pro,char *str);
   char *date_to_string(char buf[],struct date *date);
   
   /*GLOBAL*/
   struct profile profile_data_store[10000];
   int profile_data_nitems = 0;
   int quick_count = 0;
   
   /*MAIN*/
   int main(void){
   
       char line[LIMIT + 1];
       while (get_line(line)) {
           parse_line(line);
       }
       return 0;
   
   }
   
   int subst(char *str,char c1,char c2){
       int count = 0;
       while(*str != '\0'){
           if(*str == c1){
               *str = c2;
               count++;
           }
           str++;
       }
       return count;
   }
   
   int split (char *str,char *ret[],char sep,int max){
       int count = 0;//分割数
   
       while (1) {
           if(*str == '\0') {
               break;//からもじなら抜ける
           }
          
           if(count>max)break;
           ret[count++] = str;//strをいじればretも変わるように分割後の文字列にはポインタを入れる
   
           while( (*str != '\0') && (*str != sep) ){//区切り文字が見つかるまでポインタすすめる 
               str++;
           }
           
           if(*str == '\0') {
               break;//区切り文字がなかったら抜ける＝文字列はそのまま
           }                                                                                                   
   
           *str = '\0';//必ず区切り文字のはずだからくぎる
           str++;//インクリメントさせる  
       }
   
       if(count<max)count = luck;
       else if(count>max)count = over;
       return count;
   }
   
   int get_line(char *input){
       return get_line_fp(stdin,input);
   }
   
   int get_line_fp(FILE *fp,char*input){
       fprintf(stderr,"\n>>>>>");
       
       if (fgets(input, LIMIT + 1, fp) == NULL){
           fprintf(stderr,"ERROR %d:NULL--getline()\n",null);
           return 0; /* 失敗EOF */
       }
       subst(input, '\n', '\0');
       
       return 1; /*成功*/
   }
   
   void error_split(int check){
       switch(check){
           case luck:
               fprintf(stderr,"ERROR %d:luck--split()\n",LUCK);
               break;
           
           case over:
               fprintf(stderr,"ERROR %d:over--split()\n",OVER);
               break;
           
           default:
               break;
       }
       return;
   }
   
   void parse_line(char *line){
       char *ret[2];
       int com=0;
       
       if(line[0]=='%'){
           com=split(line,ret,' ',2);
           exec_command(ret[0], ret[1]);
       }
       else{
           new_profile(&profile_data_store[profile_data_nitems],line);
       }
   }
   
   void exec_command(char *cmd, char *param){
       if(strcmp(cmd,"%Q")==0||strcmp(cmd,"%q")==0){
           cmd_quit();
       }
       else if(strcmp(cmd,"%C")==0||strcmp(cmd,"%c")==0){
           cmd_check();
       }
       else if(strcmp(cmd,"%E")==0||strcmp(cmd,"%e")==0){
           cmd_pex(strtol(param,endp,base1));
       }
       else if(strcmp(cmd,"%P")==0||strcmp(cmd,"%p")==0){
           cmd_print(&profile_data_store[0],strtol(param,endp,base1));
       }
       else if(strcmp(cmd,"%R")==0||strcmp(cmd,"%r")==0){
           cmd_read(param);
       }
       else if(strcmp(cmd,"%W")==0||strcmp(cmd,"%w")==0){
           cmd_write(param);
       }
       else if(strcmp(cmd,"%F")==0||strcmp(cmd,"%f")==0){
           cmd_find(param);
       }
       else if(strcmp(cmd,"%FB")==0||strcmp(cmd,"%fb")==0){
           cmd_findb(param);
       }
       else if(strcmp(cmd,"%D")==0||strcmp(cmd,"%d")==0){
           cmd_delete(strtol(param,endp,base1));
       }
       else if(strcmp(cmd,"%S")==0||strcmp(cmd,"%s")==0){
           cmd_sort(strtol(param,endp,base1));
       }
       else if(strcmp(cmd,"%QS")==0||strcmp(cmd,"%qs")==0){
           cmd_qsort(strtol(param,endp,base1));
       }
       else if(strcmp(cmd,"%H")==0||strcmp(cmd,"%h")==0){
           cmd_help();
       }
       else if(strcmp(cmd,"%BW")==0||strcmp(cmd,"%bw")==0){
           cmd_binwrite(param);
       }
       else if(strcmp(cmd,"%BR")==0||strcmp(cmd,"br")==0){
           cmd_binread(param);
       }
       else if(strcmp(cmd,"%SIZE")==0||strcmp(cmd,"size")==0){
           cmd_size();
       }
       else {
           fprintf(stderr, "ERROR %d:%s command is not defined.--exec_command()\n",NOTDEFINED,cmd);
           fprintf(stderr,"command list : %%H\n");
       }
    }
   
   void cmd_help(){
       int i;
       char help_list[LIST][40]=
       {
           "Q : quit system","C : check data num","P [value] : print data",
           "E : print specified data","R [filename] : read csv data","W [filename] : write csv data",
           "BR : read binary data","BW : write binary data",
           "F [word] : Exact match search","FB [word] : Partial match search",
           "S [value] : sort (bubble)","QS [value] : quick sort",
           "D [value] : delete data","SIZE : size check",
       };
   
       for(i=0;i<LIST;i++){
           fprintf(stderr,"%s\n",help_list[i]);
       }
   
       return ;
   }
   
   void cmd_quit(){
       fprintf(stderr,"Are you sure you want to quit?(y or n)>>>");
       if(fgetc(stdin)=='y'){
           fprintf(stderr, "END SYSTEM.\n");
           exit(0);
       }
       else{
           return; 
       }
   }
   
   void cmd_check(){
       fprintf(stdout,"%d profile(s)\n",profile_data_nitems);
       return;
   }
   
   void cmd_print(struct profile *pro,int param){
       if(profile_data_nitems == 0){
           fprintf(stderr,"ERROR %d:No record. No print.--cmd_print()\n",NORECORD);
           return ;
       }
       int i;
       
       if(param == 0){//０のとき
       fprintf(stderr, "******print record data******\n");
           for(i=0;i<profile_data_nitems;i++){
               printdata(pro+i,i);
           }
       }
       
       else if(param > 0){//正のとき
           
           if( param > profile_data_nitems ){
               fprintf(stderr,"ERROR %d:over number of record.--cmd_print()\n",OVERNUMBERRECORD);
               fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
               return;
           }
           fprintf(stderr, "******print record data******\n");
           for(i = 0;i<param;i++){
               printdata(pro+i,i);
           }
       }
       
       else if(param < 0){//負の時
           
           param *= -1;
           if( param > profile_data_nitems ){
               fprintf(stderr,"ERROR %d:over number of record.--cmd_print()\n",OVERNUMBERRECORD);
               fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
               return;
           }
           pro += profile_data_nitems-param;
           fprintf(stderr, "******print record data******\n");
           for(i=0 ;i<param;i++){
               printdata(pro+i,profile_data_nitems-param+i);
           }
       }
       return;
   }
   
   void printdata(struct profile *pro, int i){
       fprintf(stderr,"data  : %5d ------------------------------\n",i+1);
       fprintf(stdout,"Id    : %d\n",pro->id);
       fprintf(stdout,"Name  : %s\n",pro->name);
       fprintf(stdout,"Birth : %04d-%02d-%02d\n",pro->found.y,pro->found.m,pro->found.d);
       fprintf(stdout,"Addr  : %s\n",pro->add);
       fprintf(stdout,"Com.  : %s\n\n",pro->others);
       fprintf(stderr,"--------------------------------------------\n");
   }
   
   void cmd_pex(int param){
       if(profile_data_nitems == 0 || param == 0){
           fprintf(stderr,"ERROR %d:No record. No print.--cmd_print()\n",NORECORD);
           return ;
       }
   
       if(param<0){
           param*=(-1);
       }
   
       if( param > profile_data_nitems){
               fprintf(stderr,"ERROR %d:over number of record.--cmd_print()\n",OVERNUMBERRECORD);
               fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
               return;
       }
       param-=1;
       printdata(&profile_data_store[param],param);
       return;
   }
   
   void cmd_read(char *filename){
       char line[LIMIT+1];
       FILE *fp;
       
       if((fp = fopen(filename,"r"))==NULL){
           fprintf(stderr,"ERROR %d:openfile error!!!---cmd_read()\n",NOFILEOPEN);
           return;
       }
       while(get_line_fp(fp,line)){
           parse_line(line);
       }
       fclose(fp);
       return;
   }
   
   void cmd_write(char *filename){
       FILE *fp;
       int i;
       if((fp = fopen(filename,"w"))==NULL){
           fprintf(stderr,"ERROR %d:openfile error!!!---cmd_write()\n",NOFILEOPEN);
           return;
       }
       for(i=0;i < profile_data_nitems;i++){
           fprintf(fp,"%d,",profile_data_store[i].id);
           fprintf(fp,"%s,",profile_data_store[i].name);
           fprintf(fp,"%04d-%02d-%02d,",profile_data_store[i].found.y,profile_data_store[i].found.m,profile_data_store[i].found.d);
           fprintf(fp,"%s,",profile_data_store[i].add);
           fprintf(fp,"%s",profile_data_store[i].others);
           fprintf(fp,"\n");
       }
       fclose(fp);
       fprintf(stderr,"wrote %s\n",filename);
       return;
   }
   
   void cmd_binread(char *filename){
       return;    
   }
   
   void cmd_binwrite(char *filename){
       FILE *fp;
       int i=0;
       if (fopen(filename, "wb") == NULL)
       {
           fprintf(stderr,"ERROR %d:openfile error!!!---cmd_write()\n",NOFILEOPEN);
           return;
       }
       fwrite(&profile_data_store[0],sizeof(struct profile),1,fp);
       fclose(fp);
       fprintf(stderr,"wrote %s\n",filename);
       return;
   }
   
   char *date_to_string(char buf[],struct date *date){
       sprintf(buf,"%04d-%02d-%02d",date->y,date->m,date->d);
       return buf;
   }
   
   void cmd_find(char *keyword){
       int i,check=0;
       struct profile *p;
       char found_str[11];
       
       for(i=0;i < profile_data_nitems;i++){
           p=&profile_data_store[i];
           date_to_string(found_str,&p->found);
           if( 
                   (p->id) == strtol(keyword,endp,base1)||
                   strcmp(p->name,keyword)==0||
                   strcmp(p->add,keyword)==0||
                   strcmp(p->others,keyword)==0||
                   strcmp(found_str,keyword)==0
               ){
                   printdata(p,i);
                   check=1;
           }
       }
       
       if(check==0){
           fprintf(stderr,"No match data.\n");
       }
       
       return;
   }
   
   void cmd_findb(char *keyword){
       int i,check=0;
       struct profile *p;
       char found_str[11];
       
       for(i=0;i < profile_data_nitems;i++){
           p=&profile_data_store[i];
           date_to_string(found_str,&p->found);
           if( 
                   (p->id) == strtol(keyword,endp,base1)||
                   find_kai(p->name,keyword)==0||
                   find_kai(p->add,keyword)==0||
                   find_kai(p->others,keyword)==0||
                   find_kai(found_str,keyword)==0
               ){
                   printdata(p,i);
                   check=1;
           }
       }
       if(check==0){
           fprintf(stderr,"No match data.\n");
       }
       return;
   }
   
   int find_kai(char *s, char * cp){
       char *s1, *s2;
       if( *cp == '\0') return 1; /*cpの文字列長が0ならsを返す*/ 
   
       while( *s != '\0'){
           while(*s != '\0' && *s != *cp) {/*先頭文字が合うまで探す*/
               s++;
           }
           if(*s == '\0') return 1;/*見つからない*/
           s1 = s;
           s2 = cp;
           while ( *s1 == *s2 && *s1 != '\0'){ /*cpの先頭以降の文字列が一致するか*/
               s1++;
               s2++;
           }
           if( *s2 == '\0'){/* cp の文字列は、全て一致した*/
       
               return 0;
           }
           s++; /*次の位置から、調べ直す*/
       }
       return 1;/*見つからない*/
   }
   
   void swap_struct(struct profile *i, struct profile *j){
       struct profile temp;
       
       temp = *j;
       *j = *i;
       *i = temp;
       
       return;
   }
   
   int compare_profile(struct profile *p1, struct profile *p2, int youso){
       if(youso < 0)youso*=-1;
     switch (youso) {
       case 1:
         return (p1->id) - (p2->id);break;
   
       case 2:
         return strcmp(p1->name,p2->name);break;
         
       case 3:
         return compare_date(&p1->found,&p2->found);break;
   
       case 4:
         return strcmp(p1->add, p2->add);break;
   
       case 5:
         return strcmp(p1->others, p2->others);break;
       
       default:
           return 0;break;
       }
   }
   
   int compare_date(struct date *d1, struct date *d2){
     if (d1->y != d2->y) return d1->y - d2->y;
     if (d1->m != d2->m) return d1->m - d2->m;
     return (d1->d) - (d2->d);
   }
   
   void cmd_sort(int youso){
       int i,j;
       int check=0;
   
       if(youso>5||youso<1){
           fprintf(stderr,"ERROR %d:sort param is 1 to 5.---cmd_sort()\n",PARAMERROR);
           return;
       }
       
       if(profile_data_nitems<=0){
           return;
       }
   
       for(i=0;i<profile_data_nitems;i++){
           for(j=0;j<profile_data_nitems-1;j++){
               if(compare_profile(&profile_data_store[j],&profile_data_store[j+1],youso) > 0){
                   swap_struct(&profile_data_store[j],&profile_data_store[j+1]);
                   check++;
               }
           }
       }
       fprintf(stderr,"%d swap.\n",check);
       return;
   }
   
   void cmd_qsort(int youso){
           if(youso>5||youso<1){
           fprintf(stderr,"ERROR %d:sort param is 1 to 5.---cmd_sort()\n",PARAMERROR);
           return;
       }
       
       if(profile_data_nitems<=0){
           return;
       }
       quick_sort(0,profile_data_nitems-1,youso);
       fprintf(stderr,"quicksort end.===count:%d\n",quick_count);
       quick_count=0;
       return;
       
   }
   
   void quick_sort(int left, int right,int youso){
       int i,j,pivot;
       
       i=left; 
       j=right;
       pivot=right;
       
       while(1){
           while (compare_profile(&profile_data_store[i],&profile_data_store[pivot],youso) < 0){
               i++;
           }
           while (compare_profile(&profile_data_store[pivot],&profile_data_store[j],youso) < 0){
               j++;
           }
           if(i>=j)break;
           swap_struct(&profile_data_store[i],&profile_data_store[j]);
           quick_count++;
           i++;
           j--;
       }
       
       if (left < i - 1){               /* 基準値の左に 2 以上要素があれば */
           quick_sort(left, i-1,youso);/* 左の配列をソートする */
       }
       if (j + 1 <  right){              /* 基準値の右に 2 以上要素があれば */
           quick_sort(j+1, right,youso);/* 右の配列をソートする */
       }
       return;
   }
   
   void cmd_delete(int param){
       int i;
       if( param > profile_data_nitems||param <=0){
               fprintf(stderr,"ERROR %d:error param.--cmd_delete()\n",OVERNUMBERRECORD);
               fprintf(stderr,"ERROR %d:number of item is %d\n",NUMITEM,profile_data_nitems);
               return;
       }
       for(i=param-1;i<profile_data_nitems-1;i++){
           profile_data_store[i]=profile_data_store[i+1];
       }
       profile_data_nitems-=1;
       return;
   }
   
   struct profile *new_profile(struct profile *pro,char *str){
       char *ret1[maxsplit],*ret2[maxsplit-2];
       int count=0;
       if(profile_data_nitems>=10000){
           fprintf(stderr,"ERROR %d:Can't add record--new_profile()\n",OVERNITEMS);
           return NULL;
       }
       count=split(str,ret1,',',maxsplit);
       if(count!=maxsplit){
           error_split(count);
           fprintf(stderr,"ERROR %d:wrong format of input(ex.001,name,1999-01-01,address,other)--new_profile()\n",FORMATINPUT);
           return NULL;
       }//文字列用
   
       pro->id = strtol(ret1[0],endp,base1);
       if( pro->id == 0){
           fprintf(stderr,"ERROR %d:ID is NUMBER.--new_profile()\n",FORMATID);
           return NULL;
       }
   
       strncpy(pro->name, ret1[1],70);//名前のコピー
       strncpy(pro->add, ret1[3],70);//住所
       pro->others = (char *)malloc(sizeof(char)*(strlen(ret1[4])+1));
       strcpy(pro->others, ret1[4]);//備考,MAX 1024bytes
   
       if(split(ret1[2],ret2,'-',maxsplit-2)!=maxsplit-2){
           fprintf(stderr,"ERROR %d:wrong format of date.(ex.1999-01-01)--new_profile()\n",FORMATDATE);
           return NULL;
       }//設立日
       pro->found.y = strtol(ret2[0],endp,base1);
       pro->found.m = strtol(ret2[1],endp,base1);
       pro->found.d = strtol(ret2[2],endp,base1);
       
       fprintf(stderr,"Add profile.\n");
       profile_data_nitems++;
       return pro;
   }
   
   void cmd_size(){
       fprintf(stderr,"struct profile = %d\n",sizeof(struct profile));
       fprintf(stderr,"id = %d\n",sizeof(profile_data_store[0].id));
       fprintf(stderr,"name = %d\n",sizeof(profile_data_store[0].name));
       fprintf(stderr,"add = %d\n",sizeof(profile_data_store[0].add));
       fprintf(stderr,"found = %d\n",sizeof(profile_data_store[0].found));
       fprintf(stderr,"found.y = %d\n",sizeof(profile_data_store[0].found.y));
       fprintf(stderr,"found.m = %d\n",sizeof(profile_data_store[0].found.m));
       fprintf(stderr,"found.d = %d\n",sizeof(profile_data_store[0].found.d));
       fprintf(stderr,"Com. = %d\n",sizeof(profile_data_store[0].others));
       return;
       //araiment seiyaku
   }
\end{lstlisting}
\end{document}