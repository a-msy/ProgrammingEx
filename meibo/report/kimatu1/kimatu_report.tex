\documentclass[a4j,11pt]{jarticle}
% ファイル先頭から\begin{document}までの内容（プレアンブル）については，
% 教員からの指示がない限り， { } の中を書き換えるだけでよい．
%動的メモリ確保について試問
%https://www.tablesgenerator.com/

% ToDo: 提出要領に従って，適切な余白を設定する
\usepackage[top=25truemm,  bottom=30truemm,
            left=25truemm, right=25truemm]{geometry}


% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{プログラミング演習1 \\
       期末レポート}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 今田将也 (IMADA, Masaya) \\
        学生番号: 09430509}

% ToDo: 教員の指示に従って適切に書き換える
\date{出題日: 2019年04月10日 \\
      提出日: 2019年05月26日 \\
      締切日: 2019年05月29日 \\}  % 注：最後の\\は不要に見えるが必要．

% ToDo: 図を入れる場合，以下の1行を有効にする
\usepackage{graphicx}

\begin{document}
\maketitle

% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

% 以下の7行は提出用のレポートでは必ず消すこと
%\textbf{\small※執筆上の注意：本書は空想上の課題に対するレポートの
%   執筆例である．章の構成と書くべき内容の参考として提示するもの
%    であるため，課題内容やプログラムの仕様などは，
%    実際の演習課題の指示に従って適切にまとめ直す必要がある．
%    途中まで文を書いて「・・・」によって省略している箇所があるが，
%    これに穴埋めをすることで提出できるレポートになるわけではない．
%    また，サンプルと同じ書き出しで文章を書く必要はない．}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{概要}\label{sec:gaiyou}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 以下の4行は提出用のレポートでは必ず消すこと
%\textbf{\small※執筆上の注意：概要は多すぎず少なすぎずが重要である．
%    特に，次の3点について，執筆者の取り組みの概略が読者（＝教員）に
%    伝わるようにしよう．(1) このレポートで取り組んだ課題の内容，
%    (2) 実験等によって得られた結果，(3) 結果に対しておこなった考察．\\}
プログラミング演習１にてC言語の実践的なプログラミングの演習を行った. 
演習内容としては，外部からのデータ入力を処理すること，ポインタや構造体のデータ構造について学習をした．そして，その実践的な内容として，段階的な詳細化を行いながら，名簿管理プログラムの作成を課題としてこなした．本課題を通し，データ構造管理の手法やポインタを利用した構造体の仕組み，さらに入力されたデータの編集処理の手法について新たな知識を得た．また，完成したプログラムの結果を通して，様々なデータ入力を考慮した際のエラー処理についても考察を行った．

なお，与えられたプログラムの基本仕様と要件，および，本レポートにおける実装の概要を以下に述べる．プログラムの使用方法についても記載した．

\begin{enumerate}
\setlength{\parskip}{0mm}\setlength{\itemsep}{0mm}%この1行で箇条書きの行間を調整している
\item 仕様
    \begin{enumerate}
    \item 標準入力からID，学校名，設立日，住所，備考からなるコンマ区切り形式 (CSV 形式) の名簿データを受け付けて，それらをメモリ中に登録する機能を持つ．CSV形式の例を以下に示す．

% 波括弧の内部 {...} だけ文字サイズ等を設定する書き方の例
% 以下の例はフォントサイズ：10pt 行送り：11pt
    {\fontsize{8pt}{10pt} \selectfont
        \begin{verbatim}
5100046,The Bridge,1845-11-2,14 Seafield Road Longman Inverness,SEN Unit 2.0 Open
5100224,Canisbay Primary School,1928-7-5,Canisbay Wick,01955 611337 Primary 56 3.5 Open
        :
        \end{verbatim}
    }
%% 注：行送りの変更は"指定箇所を含む段落”に効果があらわれる．
%%     fontsizeコマンドを用いて，行送りを変える場合は，
%%     その {...} の前後に空白行を入れ，段落を変えるようにすること．
%%     なお，行先頭がコメントから始まる行は空白行とは扱われない．

    \item ただし\verb|%|で始まるコマンドを受け付けて，登録してあるデータを表示したり整列したりするなどの機能を持つ．実装するコマンドを表\ref{tbl:commands}に示す．
    \end{enumerate}
\item 要件
    \begin{enumerate}
    \item 名簿データは配列などを用いて少なくとも$10000$件のデータを登録できるようにする．
          今回のプログラムでは，構造体\verb|struct profile|の配列\verb|profile_data_store[10000]|を宣言して，
          $10000$件のデータを格納できるようにする．
    \item 名簿データは構造体\verb|struct profile|および構造体\verb|struct date|を利用して，
          構造を持ったデータとしてプログラム中に定義して利用する．
          実装すべきデータ構造は表\ref{tbl:structure_profile}である．
          表中の$n$~bytesとは，$n$バイトの\verb|char|型配列を意味する．
    \end{enumerate}
\end{enumerate}

\begin{table}[t] % 表の位置は原則として t または b である．hやHは使わない．
    \centering % この1行はbegin～endの中を中央寄せにする，というコマンド
    \caption{実装するコマンド}
    \label{tbl:commands}
\begin{tabular}{|l|l|l|}
\hline
コマンド & 解説 & パラメータ範囲 \\ \hline
\verb|%C| & メモリ中のデータ件数を表示する & パラメータなし \\ \hline
\verb|%P| & メモリ中データを，$n$に応じて表示させる & \begin{tabular}[c]{@{}l@{}}n:-10000$\sim$10000\\ ($0$:全件表示\\ $n$\textgreater{}$0$:前から指定件数正順表示\\ $n$\textless{}$0$:後ろから指定件数正順表示)\end{tabular} \\ \hline
\verb|%Q| & システムを終了する & パラメータなし \\ \hline
\end{tabular}
\end{table}
	\begin{table}[t]
	\centering % この1行はbegin～endの中を中央寄せにする，というコマンド
    \caption{名簿データ}
    \label{tbl:structure_profile}
\begin{tabular}{|l|l|l|l|l|}
\hline
ID      & 学校名      & 設立日         & 住所     & 備考  \\ \hline
32bit整数 & 70 bytes & \verb|struct date| & 70bytes & 任意長 \\ \hline
\end{tabular}
	\end{table}

また，本レポートでは以下の考察課題について考察をおこなった．

\begin{enumerate}
\setlength{\parskip}{2pt}\setlength{\itemsep}{2pt}%この1行で箇条書きの行間を調整している
    \item 追加機能に関する考察．
    \item エラー処理に関する考察．
    \item 構造体 \verb|struct profile| がメモリ中を占めるバイト数についての確認．
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの作成方針}\label{sec:housin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 以下の5行は提出用のレポートでは必ず消すこと
%\textbf{\small ※執筆上の注意：講義中の説明などに基づいて計画した作成方針についてまとめる．
%    例えば，どういう手順で作成をおこなったのか？作成にあたって何を重視したのか？
%    この例は架空の講義内容に基づいて書かれている．実際の講義に合わせて内容や節構成を精査すること．
%    なお，コーディング中に考え直した細かい内容は，できる限り，
%    この章ではなく後の「作成過程における考察」でまとめること．\\}

プログラムをおおよそ以下の部分から構成することにした．
それぞれについて作成方針を立てる．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item 必要なデータ構造の宣言部（\ref{sec:declare}節）
    \item 標準入力から得た CSV データの解析部（\ref{sec:parse}節）
    \item 構文解析したデータの内部形式への変換部（\ref{sec:exchange}節）
    \item 各種コマンド実現部（\ref{sec:command}節）
\end{enumerate}


%--------------------------------------------------------------%
\subsection{宣言部} 
\label{sec:declare}
%--------------------------------------------------------------%

``宣言部''は必要な構造体を宣言する部分である．
このレポートでは概要で示した表\ref{tbl:structure_profile}に基づいて，
以下のように宣言する．

{\fontsize{10pt}{11pt} \selectfont
\begin{verbatim}
    struct date {
      int y;
      int m;
      int d;
    };

    struct profile {
      int id;
      char name[70];
      struct date found;
      char add[70];
      char *others;
    };

     struct profile profile_data_store[10000];

     int profile_data_nitems = 0;

\end{verbatim}
}
%% 注：行送りの変更は"指定箇所を含む段落”に効果があらわれる．
%%     fontsizeコマンドを用いて，行送りを変える場合は，
%%     その {...} の前後に空白行を入れ，段落を変えるようにすること．
%%     なお，行先頭がコメントから始まる行は空白行とは扱われない．

ここでは，名簿管理に必要なデータを定義している．\verb|struct date|においては，設立日の設定に必要な変数\verb|y|，\verb|m|，\verb|d|を定義した．順に，設立年，設立月，設立日を表している．\verb|struct profile|では，一つ当たりデータの構造を作るために利用している．\verb|int id|はID，\verb|char name|は学校名，\verb|struct| \verb|date found|は設立日，\verb|char add|は住所，\verb|char others|は備考を設定している．これにより仕様に必要なデータを格納することが可能になっている．

%--------------------------------------------------------------%
\subsection{解析部} \label{sec:parse}
%--------------------------------------------------------------%

``解析部''は入力された文字列を判別し処理をおこなう箇所である．
しかし，このままでは，仕様を実現するための方法が曖昧であるうえフローチャートも複雑になる懸念があるうえ，今回の仕様の実現には手間が多くかかりそうである．
そこで，段階的詳細化の考え方に基づいてさらなる詳細化をおこなって，プロトタイプを作りながらボトムアップによる実装をすることにした．
まず，下記の(a)から(e)のように分割することにする．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
\renewcommand{\labelenumi}{(\alph{enumi})} % この1行はリスト見出しを(a), (b)に変えるためのコマンド
    \item 標準入力から読むべき行が残っている間，文字の配列\verb|char line[]|に1行分を読み込む．
    \item \verb|line|の1文字目が，\verb|'%'|ならば，2文字目をコマンド名，3文字目以降をその引数として，決定されたコマンドを実行する．
    \item さもなくば\verb|line|を新規データとみなし\verb|','|を区切りとして5つの文字列に分割する．
    \item 分割してできた5つの文字列を変換部に渡し構造体に代入する．
    \item 次の行を読み込む
\end{enumerate}
コマンドを入力させるか，新規データを入力させるか選択したのちに，以上の処理をさせるように一段階詳細化させることも考慮したが，名簿管理プログラムということが自明であるため，プログラム起動時にコマンドかそうでないかを判別して処理させることで実装した．ここで扱う文字列は最大数が$1024$に限定されているため入力文字数に注意する必要がある．

%--------------------------------------------------------------%
\subsection{変換部} \label{sec:exchange}
%--------------------------------------------------------------%

``変換部''は分割されたCSVデータもしくは新規入力データを項目毎に型変換し，
対応する構造体メンバに代入する部分である．
メンバとして様々な型を用いているため，適切な代入の使い分けが必要となる．

文字列は関数\verb|strcpy|を用いて代入する．
数値の場合，関数\verb|strtol|を用いて文字列を数値に変換してから代入する．
構造体\verb|struct date|であるメンバ\verb|y，m，d|については\verb|split|関数を実行し，文字列を分割してから代入数値としてする．

なお，構造体への代入については，\verb|strcpy|関数を用いることで容易に実装することができる．
例えば，\verb|"2014-10-25"|のような文字列を\verb|split|関数により分割し，
\verb|strcpy|関数によって入力されたデータを\verb|struct profile|内の\verb|struct date|に年と月と日を格納するという処理は，入力された文字列を\verb|','|により分割する処理と同じ処理である．
従って，区切り文字がCSVの\verb|','|とは異なり，区切り文字が\verb|-|になること以外は同様に記述できるはずである．

また，解析部から与えられた文字列はメモリ内に保持されているものではないデータであることにも注意する必要がある．
つまり，変換部で文字列を処理する際には，入力された文字列に対して変換を行い，結果を表示をするだけではなく，
関数\verb|new_profile|を使って受け取ったデータをメモリ内に保持しておく作業を行わなければならないことに気をつける必要がある．

%--------------------------------------------------------------%
\subsection{各種コマンド実現部} \label{sec:command}
%--------------------------------------------------------------%

``各種コマンド実現部''は，表\ref{tbl:commands}にある実装コマンドの，実際の処理をおこなう部分である．
このレポートでは，具体的には，登録されているデータ件数を表示する機能と，指定形式でデータ内容を表示する機能，また，システムを終了させるための機能の3つを実装している．

登録されているデータ件数を表示するためには（\verb|%C|），グローバル変数にて宣言している
\verb|profile| \verb|_data| \verb|_nitems|の値を表示すればよい．グローバル変数で宣言したのにも理由があり，\verb|main|関数内でこの変数を宣言してしまうと，別関数で利用する際に値の受け渡しが発生し，手間が増えるためグローバル変数として宣言した．

登録されているデータを表示するには（\verb|%P n|）は\verb|printf|関数でメモリ内のデータを各項目毎に表示すればよい．
ただし，与えられた引数が負の場合は，逆順ではなくデータを後ろから正順で表示するため，ポインタの位置に注意する必要がある．
また，データ件数が0件の場合でも上記コマンドは実行される．


%\%Cのことかいてませえええええええええええええええええん。。書け...
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムおよびその説明}\label{sec:explain}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 以下の6行は提出用のレポートでは必ず消すこと
%\textbf{\small ※執筆上の注意：変数や数値は$\backslash$verbや\$\$
%    で囲って，適切な書体で記述することを忘れずに．
%    なお，このサンプルでは``わざと''一部の処理を省略している．
%    見た目の違いを確認して，自分のレポートでは処理を忘れないようにしよう．
%    また，この章はこのレポートサンプルの2章に基づいて書かれているが，
%    そもそも2章が架空の講義内容に基づいて書かれている点に注意すること．\\}


プログラムリストは\ref{sec:program}節に添付している．プログラムは全部で235行からなる．
以下では，前節の作成方針における分類に基づいて，プログラムの主な構造について説明する．

%--------------------------------------------------------------%
\subsection{汎用的な関数の宣言（62行目から112行目）}
%--------------------------------------------------------------%

まず，汎用的な文字列操作関数として，
\verb|subst()|関数を62から72行目で宣言し，\verb|split()|関数を74から102行目で宣言，さらに\verb|get_line()|関数を105から111行目で宣言している．

\verb|subst| は，引数の\verb|str|が指す文字列中の\verb|c1|文字を\verb|c2|に置き換える．
プログラム中では，入力文字列中の末尾に付く改行文字をヌル文字で置き換えるために使用している．

\verb|split| は 引数の\verb|str| が指す文字列を区切文字 \verb|c| で分割し，
分割した各々の文字列を指す複数のポインタからなる配列を返す関数である．
プログラム中では，CSVを\verb|','|で分割し，分割後の各文字列を返すのに使用されている．
また，``2004-05-10'' のような日付を表す文字列を `-' で分割して，\verb|struct date| を生成する際にも使用している．

\verb|get_line()|は，標準入力からの入力を受け付けて，引数\verb|input|へ格納後，\verb|input|の内容に応じて処理を行わせている．具体的には，標準入力の入力\verb|NULL|だった場合に失敗を意味するように$0$を返し，
%--------------------------------------------------------------%
\subsection{変換部（208行目から235行目）}
%--------------------------------------------------------------%

12〜16行目は \verb|struct date| 型の宣言部である．メンバについては，変数\verb|y|は設立年，変数\verb|m|は設立月，変数\verb|d|は設立日にそれぞれ対応させている．

18〜24行目は \verb|struct profile| 型の宣言部，208〜235行目はそれを扱う関数\verb|new_profile|である．
メンバについては，設立日を入れ子構造にしている．
こうすることで，要素を管理しやすくできる．なお，備考に対応する文字列\verb|*others|は任意長を許すようにしているため，\verb|malloc|関数と\verb|strlen|関数を用いて文字列を動的に格納できるようにした. 
文字列から各データ型への変換を担う関数は，\verb|struct new\_profile| とすることで，変換部であることを明確にした．
具体的な処理内容としては，受け取った文字列\verb|str|を分割し，分割した文字列を\verb|ret1[]|に格納し，その後要素ごとに対応する構造体メンバにエラー検出のある\verb|strncpy|関数を用いて格納している．設立日については，\verb|ret2[]|を用意し，各メンバに対応するよう格納させている．

%--------------------------------------------------------------%
\subsection{各種コマンド実現部（124行目から207行目）}
%--------------------------------------------------------------%
40〜43行目の各種コマンド実現に必要な関数群は，\verb|cmd_処理名| という名前に統一することで，関数であることを明確にした．
コマンド\verb|%P|は\verb|cmd_print()|，コマンド\verb|%C|は\verb|cmd_check()|にそれぞれ対応している．

124--144行目は，\verb|%P|，\verb|%C|，\verb|%Q|のコマンドを解釈して
適切な関数を呼び出す部分である．

\verb|%P|に対応する関数\verb|cmd_print()|の処理内容としては，154から207行目に記載してある．内容は，表\ref{tbl:commands}に記載した．

\verb|%C|，\verb|%Q|はそれぞれ，146行目からと150行目からに処理内容を記述した．
%--------------------------------------------------------------%
\subsection{解析部（113行目から122行目）}
%--------------------------------------------------------------%
53から60行目は\verb|main()|関数で，
113から122行目は，\verb|parse_line()|関数であり，作成方針で説明した解析部の動作におおよそ相当する．
ただし (c) の つの文字列に分割する部分は，解析部の\verb|main()|関数では実現せず，
処理内容を明確にするために変換部である\verb|new_profile()|関数中で\verb|split|を呼出すことにしている．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{プログラムの使用法}\label{sec:use}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 提出するレポートでは以下5行は必ず消すこと
%\textbf{\small ※執筆上の注意：この節はプログラムの使用法を説明す
%    る節である．最低限，起動の方法，入力の形式と方法，出力の読み方
%    を入れること．当然，実装したコマンドすべてを説明すべきであるが，
%    このサンプルのように説明に使う実行例が1つである必要はない．
%    なお，このサンプルは架空の課題であり，動作環境も架空である．\\}

本プログラムは名簿データを管理するためのプログラムである．
CSV形式のコンマ区切りのデータと \% で始まるコマンドを標準入力から受け付け，
処理結果を標準出力に出力する．入力形式の詳細については，第\ref{sec:gaiyou}節を参照されたい．

プログラムは，                                   で動作を確認しているが，
一般的な UNIX で動作することを意図している．
\verb|gcc|でコンパイルした後，標準入力から入力ファイルを与える．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
   % gcc -Wall -o program1 program1.c
   % ./program1 <　test.txt
 \end{verbatim}
}
%% 注：行送りの変更は"指定箇所を含む段落”に効果があらわれる．
%%     fontsizeコマンドを用いて，行送りを変える場合は，
%%     その {...} の前後に空白行を入れ，段落を変えるようにすること．
%%     なお，行先頭がコメントから始まる行は空白行とは扱われない．
プログラムの出力結果としてはCSVデータの各項目を読みやすい形式で出力する．
例えば，下記の \verb|test.txt| に対して，

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
  111,The Bridge,1845-11-2,Okayama,SEN Unit 2.0 Open
  222,Bower School,1908-1-19,Kagawa,01955 641225 Primary 25 2.6 Open
  333,Canisbay School,1928-7-5,Tokyo,01955 611337 Primary 56 3.5 Open
  %C
  %P 2
  %Q
 \end{verbatim}
}
\noindent % noindentとはここでは段落を変えない（一字下げをしない）というコマンド．
以下のような出力を得る．

{\fontsize{10pt}{11pt} \selectfont
 \begin{verbatim}
3 profile(s)
Id    : 111
Name  : The Bridge
Birth : 1845-11-02
Addr  : Okayama
Com.  : SEN Unit 2.0 Open

Id    : 222
Name  : Bower School
Birth : 1908-01-19
Addr  : Kagawa
Com.  : 01955 641225 Primary 25 2.6 Open

 \end{verbatim}
}

\noindent
入力中の\verb|%C|はこれまでの入力データの件数を表示することを示し，\verb|%P 2|は入力したデータのうち，先頭から2件分のデータを表示することを示している．なお，\verb|%Q|はシステムを終了することを示す．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{作成過程における考察}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%以下の3行は提出レポートでは不要なため消すこと．
%\textbf{\small ※執筆上の注意：ここでは，作成中に試行錯誤した内容，
%    例えば，「Aという実装ではなくBという実装にしたのはなぜか？」
%    などについて，バランスよくまとめる．\\}

第\ref{sec:housin}節で述べた実装方針に基づいて，第\ref{sec:explain}節ではその実装をおこなった．
しかし，実装にあたっては実装方針の再検討が必要になる場合があった．
本節では，名簿管理プログラムの作成過程において検討した内容，
および，考察した内容について述べる．

%--------------------------------------------------------------%
\subsection{関数\texttt{split}についての考察}
%--------------------------------------------------------------%

関数\verb|split|については方針通りに実装することができたが，容易に実装することはできなかった．当初はコンマまでの文字列を別の配列に保存することを繰り返して実装しようとしていたが，これではコンマの数で文字列を判断することになるため失敗した．そこで文字列を破壊的に分割し別途規定数用意した文字配列にアドレスを格納することで実装できた．文字列を丸ごとコピーすることも考えられたが，その方法は，入力した倍のメモリ量が必要な上に使わなくなったメモリを開放する手間が増えるため用いなかった．

%--------------------------------------------------------------%
\subsection{関数\texttt{get\_line}についての考察}
%--------------------------------------------------------------%
標準入力からの入力について当初は，\verb|main|関数の中で\verb|while|文繰り返し入力を行わせて，入力の度に
入力内容が\verb|NULL|でないか調べ関数\verb|subst|を適用する方法をとっていたが，\verb|while|文を脱する処理も記述しなければならないため手間が増えた．そこで，今回は入力内容に問題がなければ$1$を，あれば$0$を返す方針で実装を行った．これで，もし別の関数内で標準入力からの入力を行う際でも使いまわすことができ汎用性を持たせることができる．

%--------------------------------------------------------------%
\subsection{関数\texttt{new\_profile}についての考察}
%--------------------------------------------------------------%
関数\verb|new_profile()|の実装では，単に文字列を受け取り，その文字列を操作した後に，用意している配列\verb|profile_data_store|にコピーする方法も考えられたが，値を渡すことになり使用するメモリの量が増えると考えた．そのため，ポインタによるアドレス渡しによって実装を行った．また，配列を構造体配列として宣言しているので，ここでは構造体を返り値として設定した．
そして，文字列を数値に変換する際にはエラー検出のある\verb|strtol|関数を用いた．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{結果に関する考察}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%以下の5行は提出レポートでは不要なため消すこと．
%\textbf{\small ※執筆上の注意：考察課題を中心にまとめる．
%    自分で考えた考察課題を書くことも強く推奨しているが，
%    「作成過程における考察」とは区別して書くこと．
%    「作成されたプログラムから考察できること」を求めている．
%    また，単なる感想で終わるような内容を書いてはいけない．\\}

演習課題のプログラムについて仕様と要件をいずれも満たしていることを
プログラムの説明および使用法における実行結果例によって示した．
ここでは，概要で挙げた以下の項目について考察を述べる．

\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item 不足機能についての考察
    \item エラー処理についての考察
\end{enumerate}

%--------------------------------------------------------------%
\subsection{不足機能についての考察}
%--------------------------------------------------------------%
不足機能については，以下の内容が考えられる．
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item データの削除についての機能
    \item 入力したデータの並び替えに関する機能
　　\item 指定語句を検索し，その結果に合致するデータの表示
　　\item なんの機能があるか表示する\verb|help|のような機能
\end{enumerate}
標準入力から受け付けたデータを編集したい場合に備え，誤って入力したデータを削除できる機能が必要だと考えた．指定のデータ番号を削除もしくは，入力した直近のデータの削除の2通りが考えられる．

また，並び替えの機能についてだが，仮に実装する場合，名簿データの構成上，ID順，学校名順，設立日順，住所順に並び替える機能が必要だと考えた．さらに，各要素について，降順と昇順に並び替えることも必要になるだろう．

登録できるデータ件数が$10000$件と仕様にあるため，必然的にデータ数が多くなれば管理も複雑になることが多くなる．そこで，登録したデータを容易に検索できるシステムがあればさらに便利に当システムを利用することが可能になるのではないかと考えた．
なお，これらの機能を見れる機能も実装したい．

%--------------------------------------------------------------%
\subsection{エラー処理についての考察}
%--------------------------------------------------------------%
\begin{enumerate}
\setlength{\parskip}{2pt} \setlength{\itemsep}{2pt}
    \item CSVデータ処理中のエラー処理
    \item split関数におけるエラー処理
　　\item cmd\_print関数におけるエラー処理
    \item new\_profile関数におけるエラー処理
\end{enumerate}


%--------------------------------------------------------------%
\subsubsection{CSVデータ処理中のエラー処理}
%--------------------------------------------------------------%

CSVデータ中に，不正なデータが含まれていた場合の処理について考察する．
エラーが含まれていた場合は，以下のような対処が考えられる．

\begin{description} % descriptionで見出し後に改行するときは ~\\ とする．
  \item[(1) エラーのあった行を指摘して，無視する]~\\
1度の入力で，エラーを多く見つけることができるようになるため，エラー処理を実装する際はこの方法をとることが望ましいと考える．しかし，そのエラー後の入力へどのように復帰させるのかといったことや，エラーのあった入力文字列の扱いについて考える必要があるため，プログラムが複雑になることが懸念される．
  \item[(2) エラーのあった行を指摘して，終了する]~\\
    この方法は，入力中にいずれかの1つのエラーを発見することしかできない．
    しかし，エラーのあった入力をデータを無視してしまうと
    以降のデータ入力の内容を確認する際の処理にも影響がでるような場合には，
    この方法を採らざるを得ないこともあると考えられる．
\end{description}

エラーのあった行を指摘せず，終了または無視するという方法も考えられるが，正常終了との区別が付かない上に，どの状態でエラーが発生しているのか確認をとることができないため実用的でないと考えた．

今回は，エラーのあった行を指摘して，無視する方法がよいと考えた．
現時点ではエラー処理については未実装であるため，プログラム中に\verb|error:|で始まるコメントを書いて検討の目印としている．また，エラーのあった内容を指摘するためには，\verb|enum|という機能を利用してどのエラーなのかユーザが一度見て理解できるように，標準エラー出力を利用してエラーの内容を表示させるのが良いだろう．

%--------------------------------------------------------------%
\subsubsection{\texttt{split}関数におけるエラー処理}
%--------------------------------------------------------------%
関数\verb|split|におけるエラー処理としては，規定分割数に達しない場合もしくは，規定分割数を超えた場合の処理が考えられる．
実装方法として例えば，ここでは返り値として変数\verb|count|を返しているが，この前に変数\verb|count|が規定分割数を超えているか否かという分岐処理を行い，超えていれば$-1$を，達していなければ$-2$を返し，その値に応じて別関数もしくは同関数内でエラー表示を行わせることが考えられる．
%--------------------------------------------------------------%
\subsubsection{\texttt{cmd\_print}関数におけるエラー処理}
%--------------------------------------------------------------%
関数\verb|cmd_print|は，入力された変数\verb|param|が\verb|profile_data_nitems|より多いと全件表示させているが，今後はこれもエラーとしたい．何件入っているかに関わらず処理を行わせると，\verb|cmd_check|でデータ件数を確認する理由がなくなってしまうと考えているからである．

また，データ件数が$0$件の場合，セグメンテーションフォールトなどは起こらないが，せめてデータが入っていないという表示を行わせるべきであると考える．
%--------------------------------------------------------------%
\subsubsection{\texttt{new\_profile}関数におけるエラー処理}
%--------------------------------------------------------------%

まず，関数\verb|new_profile|は，データ形式が正しいか否かに関わらずデータ件数をインクリメントさせているため，データ形式が不正な場合はインクリメントさせないようにするべきである．\verb|new_profile|への引数として渡している構造体配列の変数を変更し，返り値を返す際に成功していればインクリメントさせる方法が考えられる．

この実装の場合，不正なデータ形式が入力ときは\verb|NULL|を返す処理を追加しなくてはならない．不正なデータとして考えられるのは，受け取ったCSVデータが5分割でない場合，設立日が\verb|-|で区切られていない場合，そして，IDが数字でない場合が考えられる．その他はエラーにしなくともよいだろう．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{感想}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
課題が与えられた際は，実装方針が全くわからず完成するか不安だった．しかし，いきなりプログラムを組むのではなく，日本語で段階的に流れを組み，徐々に詳細化していき，プログラムをしていくという方法を学んだため，頭でイメージを立てながらプログラムを組むことができた．しかし，メモリ使用量などデータ構造についてはさらに検討の余地があると感じる．
また，C言語は，オブジェクト指向型言語ではないがポインタや構造体を用いることでこれに近い動きをできることに驚いた．しかし，文字列の代入や値の受け渡しについては最近の言語とは異なることが多いように感じた．今回の課題を通して，ポインタと構造体に関する理解を深められたように思うが，まだまだ足りないため，考察内容を実装する中でさらに理解を深められるようにしたい．
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{作成したプログラム}\label{sec:program}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

作成したプログラムを以下に添付する．

%
% 行番号付きのリストを挿入
%   cat -n ds-sample.c > ds-sample.txt
% としたものを貼付する．
% なお， fold コマンドを使うと指定行数で折り返すことができる．
% 詳しくは fold --help を実行してヘルプを読んでみるとよい．
%
{\fontsize{10pt}{11pt} \selectfont
\begin{verbatim}
     1  #include <stdio.h>
     2  #include <stdlib.h>
     3  #include <string.h>
     4
     5  #define LIMIT 1024
     6  #define maxsplit 5//最大分割数
     7  #define luck -1
     8  #define over -2
     9  #define endp NULL//strtol 用ポインタ
    10  #define base1 10//10進数
    11
    12  struct date {
    13      int y;//year
    14      int m;//month
    15      int d;//day
    16  };
    17
    18  struct profile{
    19      int id;//id
    20      char name[70];//schoolname
    21      struct date found;
    22      char add[70];//address
    23      char *others;//備考
    24  };
    25
    26  /*subst*/
    27  int subst(char *str,char c1,char c2);
    28
    29  /*split*/
    30  int split(char *str,char *ret[],char sep,int max);
    31  void error_split(int check);
    32
    33  /*get_line*/
    34  int get_line(char *input);
    35
    36  /*parse_line*/
    37  void parse_line(char *line);
    38
    39  /*cmd*/
    40  void cmd_quit();
    41  void cmd_check();
    42  void cmd_print(struct profile *pro,int param);
    43  void exec_command(char cmd, char *param);
    44
    45  /*profile*/
    46  struct profile *new_profile(struct profile *pro,char *str);
    47
    48  /*GLOBAL*/
    49  struct profile profile_data_store[10000];
    50  int profile_data_nitems = 0;
    51
    52  /*MAIN*/
    53  int main(void){
    54
    55      char line[LIMIT + 1];
    56      while (get_line(line)) {//nullでない限り続ける
    57          parse_line(line);
    58      }
    59      return 0;
    60  }
    61
    62  int subst(char *str,char c1,char c2){
    63      int count = 0;
    64      while(*str != '\0'){
    65          if(*str == c1){//指定文字なら変換
    66              *str = c2;
    67              count++;
    68          }
    69          str++;
    70      }
    71      return count;
    72  }
    73
    74  int split (char *str,char *ret[],char sep,int max){
    75      int count = 0;//分割数
    76
    77      while (1) {
    78          if(*str == '\0') {
    79              break;//からもじなら抜ける
    80          }
    81
    82          if(count>max)break;
    83          ret[count++] = str;
    84          //strをいじればretも変わるように分割後の文字列にはポインタを入れる
    85
    86          while( (*str != '\0') && (*str != sep) ){
    87              //区切り文字が見つかるまでポインタすすめる
    88              str++;
    89          }
    90
    91          if(*str == '\0') {
    92              break;
    93              //区切り文字がなかったら抜ける＝文字列はそのまま
    94          }                                                               
    95
    96          *str = '\0';
    97          //必ず区切り文字のはずだからくぎる
    98              str++;
    99          //インクリメントさせる
   100      }
   101      //error:カウント数が大きいもしくは、規定カウント数以下の場合エラー
   102      return count;
   103  }
   104
   105  int get_line(char *input){
   106      if (fgets(input, LIMIT + 1, stdin) == NULL){
   107          return 0; /* 失敗EOF */
   108      }
   109      subst(input, '\n', '\0');
   110      return 1; /*成功*/
   111  }
   112
   113  void parse_line(char *line){
   114      if(line[0]=='%'){
   115          exec_command(line[1], &line[3]);
   116          //[0]->% [1]->P [2]->空白 [3]->2など
   117      }
   118      else{
   119          new_profile(&profile_data_store[profile_data_nitems++],line);
   120          //error:データが不正でもインクリメントされている
   121      }
   122  }
   123
   124  void exec_command(char cmd, char *param)
   125   {
   126      switch(cmd){
   127          case 'Q':
   128              cmd_quit();
   129          break;
   130
   131          case 'C':
   132              cmd_check();
   133          break;
   134
   135          case 'P':
   136              cmd_print(&profile_data_store[0],strtol(param,endp,base1));
   137          break;
   138
   139          default:
   140              fprintf(stderr,"Invalid command %c: ignored.\n", cmd);
   141              //定義されていないコマンド
   142          break;
   143      }
   144   }
   145
   146  void cmd_quit(){
   147      exit(0);
   148      return;
   149  }
   150  void cmd_check(){
   151      printf("%d profile(s)\n",profile_data_nitems);
   152      return;
   153  }
   154  void cmd_print(struct profile *pro,int param){
   155      if(profile_data_nitems == 0){
   156          //error:データがないことを示す
   157          return ;
   158      }
   159      int i;
   160
   161      if(param == 0){//０のとき
   162          for(i=0;i<profile_data_nitems;i++){
   163              printf("Id    : %d\n",(pro+i)->id);
   164              printf("Name  : %s\n",(pro+i)->name);
   165              printf("Birth : %04d-%02d-%02d\n",(pro+i)->found.y,(pro+i)->
found.m,(pro+i)->found.d);
   166              printf("Addr  : %s\n",(pro+i)->add);
   167              printf("Com.  : %s\n",(pro+i)->others);
   168              printf("\n");
   169          }
   170      }
   171
   172      else if(param > 0){//正のとき
   173
   174          if( param > profile_data_nitems ){
   175              param=profile_data_nitems;
   176              /*error:すでに配列に入ってる要素よりも大きい場合は全件表示するよりも、
   177              データ数オーバーでエラーにするほうが良いのでは？
   178              負の時も同様*/
   179          }
   180          for(i = 0;i<param;i++){
   181              printf("Id    : %d\n",(pro+i)->id);
   182              printf("Name  : %s\n",(pro+i)->name);
   183              printf("Birth : %04d-%02d-%02d\n",(pro+i)->found.y,(pro+i)->
found.m,(pro+i)->found.d);
   184              printf("Addr  : %s\n",(pro+i)->add);
   185              printf("Com.  : %s\n",(pro+i)->others);
   186              printf("\n");
   187          }
   188      }
   189
   190      else if(param < 0){//負の時
   191
   192          param *= -1;
   193          if( param > profile_data_nitems ){
   194              param=profile_data_nitems;
   195          }
   196          pro += profile_data_nitems-param;
   197          for(i=0 ;i<param;i++){
   198              printf("Id    : %d\n",(pro+i)->id);
   199              printf("Name  : %s\n",(pro+i)->name);
   200              printf("Birth : %04d-%02d-%02d\n",(pro+i)->found.y,(pro+i)->
found.m,(pro+i)->found.d);
   201              printf("Addr  : %s\n",(pro+i)->add);
   202              printf("Com.  : %s\n",(pro+i)->others);
   203              printf("\n");
   204          }
   205      }
   206      return;
   207  }
   208  struct profile *new_profile(struct profile *pro,char *str){
   209      char *ret1[maxsplit],*ret2[maxsplit-2];
   210
   211      if(split(str,ret1,',',maxsplit)!=maxsplit){
   212          return NULL;
   213      }//文字列用
   214
   215      //error:idが数字ではないときは形式が違うからエラーにしたい
   216      pro->id = strtol(ret1[0],endp,base1);
   217
   218      strncpy(pro->name, ret1[1],70);//名前のコピー
   219      pro->name[70]='\0';
   220
   221      if(split(ret1[2],ret2,'-',maxsplit-2)!=maxsplit-2){
   222          return NULL;
   223      }//設立日
   224      pro->found.y = strtol(ret2[0],endp,base1);
   225      pro->found.m = strtol(ret2[1],endp,base1);
   226      pro->found.d = strtol(ret2[2],endp,base1);
   227
   228      strncpy(pro->add, ret1[3],70);//住所
   229      pro->add[70]='\0';
   230
   231      pro->others = (char *)malloc(sizeof(char)*(strlen(ret1[4])+1));
   232      strcpy(pro->others, ret1[4]);//備考
   233
   234      return pro;//構造体proを返す
   235  }
\end{verbatim}
}
%% 注：行送りの変更は"指定箇所を含む段落”に効果があらわれる．
%%     fontsizeコマンドを用いて，行送りを変える場合は，
%%     その {...} の前後に空白行を入れ，段落を変えるようにすること．
%%     なお，行先頭がコメントから始まる行は空白行とは扱われない．

% 以下の3行は提出用のレポートでは必ず消すこと．
%\textbf{\small ※執筆上の注意：余白部分に文字がはみ出していないか，よく確認する．
%    例えば，\LaTeX によるコンパイル時のWarningメッセージを確認しよう．
%    \texttt{Overfull hbox}が出ていたら，はみ出している場所があるはずである．}

\end{document}
